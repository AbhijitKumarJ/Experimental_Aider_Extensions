<!DOCTYPE html>
<html>
<head>
<title>Aider Chat Context - 20250202_212110</title>
<style>
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; color: #333; }
.container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
.header { border-bottom: 2px solid #eee; margin-bottom: 20px; padding-bottom: 10px; }
.section { margin-bottom: 30px; }
.file-content { background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; font-family: "Consolas", "Monaco", monospace; }
.chat-message { margin: 10px 0; padding: 10px; border-radius: 5px; }
.user-message { background: #e3f2fd; border-left: 4px solid #2196f3; }
.assistant-message { background: #f5f5f5; border-left: 4px solid #9e9e9e; }
.system-message { background: #fff3e0; border-left: 4px solid #ff9800; }
.repo-map { background: #f1f8e9; border-left: 4px solid #8bc34a; }
pre { margin: 0; padding: 10px; overflow-x: auto; }
.metadata { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 20px; }
.metadata-item { background: #fff; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
.file-list { list-style: none; padding: 0; }
.file-list li { padding: 5px 0; }
.stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }
</style>
</head>
<body>
<div class="container">
<div class="header">
<h1>Aider Chat Context - 2025-02-02 21:21:10</h1>
</div>
<div class="metadata section">
<div class="metadata-item">
<h3>Model Information</h3>
<p>Main Model: gemini/gemini-1.5-flash-latest</p>
<p>Edit Format: whole</p>
</div>
<div class="metadata-item">
<h3>Files in Chat</h3>
<div class="stats">
<div>Total Files: 30</div>
<div>Total Lines: 4,554</div>
<div>Total Chars: 152,198</div>
</div>
<ul class="file-list">
<li>LICENSE (11.1KB, 201 lines)</li>
<li>README.md (6.1KB, 181 lines)</li>
<li>custom_aider/commands/__init__.py (0.1KB, 3 lines)</li>
<li>custom_aider/commands/aichat_commands.py (3.2KB, 99 lines)</li>
<li>custom_aider/commands/clip_edit_command.py (2.5KB, 72 lines)</li>
<li>custom_aider/commands/context_backup_command.py (1.7KB, 48 lines)</li>
<li>custom_aider/commands/context_create_command.py (4.0KB, 126 lines)</li>
<li>custom_aider/commands/context_load_command.py (4.1KB, 112 lines)</li>
<li>custom_aider/commands/context_show_command.py (8.3KB, 216 lines)</li>
<li>custom_aider/commands/customchat_command.py (3.9KB, 130 lines)</li>
<li>custom_aider/commands/docrag_commands.py (10.0KB, 289 lines)</li>
<li>custom_aider/commands/editor_tkinter_command.py (2.0KB, 67 lines)</li>
<li>custom_aider/commands/existing_commands.py (10.5KB, 293 lines)</li>
<li>custom_aider/commands/explain_command.py (11.3KB, 307 lines)</li>
<li>custom_aider/commands/git_commands.py (1.9KB, 64 lines)</li>
<li>custom_aider/commands/load_templated_command.py (5.9KB, 174 lines)</li>
<li>custom_aider/commands/load_templated_script_command.py (8.7KB, 266 lines)</li>
<li>custom_aider/commands/timemachine_command.py (10.6KB, 294 lines)</li>
<li>custom_aider/commands/utility_commands.py (3.8KB, 112 lines)</li>
<li>custom_aider/commands_registry.py (3.2KB, 83 lines)</li>
<li>custom_aider/custom_aider_main.py (1.7KB, 53 lines)</li>
<li>custom_aider/custom_coder.py (1.5KB, 39 lines)</li>
<li>custom_aider/docs/addlessonlist.py (0.5KB, 16 lines)</li>
<li>custom_aider/docs/extension-docs.md (10.4KB, 369 lines)</li>
<li>custom_aider/docs/index.html (7.9KB, 258 lines)</li>
<li>custom_aider/docs/markdown-viewer-with-filelist.html (7.8KB, 256 lines)</li>
<li>custom_aider/docs/runserver.bat (0.1KB, 3 lines)</li>
<li>custom_aider/docs/runserver.sh (0.2KB, 11 lines)</li>
<li>custom_aider/docs/user-guide.md (7.0KB, 384 lines)</li>
<li>custom_aider/monkey_patch.py (0.9KB, 28 lines)</li>
</ul>
</div>
<div class="metadata-item">
<h3>Git Information</h3>
<p>Branch: main</p>
<p>Last Commit: 5744bca</p>
<p>Author: Abhijit</p>
<p>Date: 2025-02-02 21:20:50+05:30</p>
</div>
</div>
<div class="section">
<h2>Chat History</h2>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>based on commands in commands folder of customaider, can you correct the command names and other details in user-guide.md file</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>Here&#39;s the updated `user-guide.md` file with corrected command names and other details based on the commands found in the `custom_aider/commands` folder.  I&#39;ve also made some minor stylistic improvements for clarity.


custom_aider/docs/user-guide.md
````
# Aider Extension User Guide

A comprehensive guide to using the extended Aider command-line interface with all its enhanced features.

## Table of Contents

1. [Getting Started](#getting-started)
2. [Basic Usage](#basic-usage)
3. [Working with Documents](#working-with-documents)
4. [Enhanced Git Integration](#enhanced-git-integration)
5. [Custom Chat Features](#custom-chat-features)
6. [Code Analysis Tools](#code-analysis-tools)
7. [Editor Integration](#editor-integration)
8. [Web and Voice Features](#web-and-voice-features)
9. [AIChat API Integration](#aichat-api-integration)
10. [Configuration](#configuration)
11. [Tips and Tricks](#tips-and-tricks)


## Getting Started

### Installation

1. Clone the repository:
```bash
git clone https://github.com/AbhijitKumarJ/Experimental_Aider_Extensions.git
cd Experimental_Aider_Extensions
```

2. Install required dependencies:
```bash
pip install aider-chat jinja2 llama-index-core llama-index-embeddings-huggingface pygments pyperclip streamlit requests
```

Optional dependencies for specific features:
```bash
# For voice commands
pip install SpeechRecognition

# For enhanced editor features
pip install tkinter  # Usually comes with Python
```

3. Start the extended Aider:
```bash
python main.py
```

### Initial Configuration

1. Create a configuration file `.aider.conf.yml`:
```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree-only: true
```

2. Set up keywords file `.aider.keywords.json`:
```json
{
    &quot;api&quot;: &quot;REST API with JSON responses&quot;,
    &quot;tests&quot;: &quot;Unit tests using pytest with mocking&quot;
}
```

## Basic Usage

### Starting a Session

```bash
# Start with default settings
python main.py

# Start with specific model
python main.py --model gemini/gemini-1.5-flash-latest

# Start with specific directory
python main.py /path/to/project
```

### Getting Help

```bash
# Show all available commands
&gt; /help

# Get help for specific command
&gt; /help createragfromdoc
```

## Working with Documents

### RAG (Retrieval Augmented Generation)

Creating and querying document-based RAGs:

```bash
# Create a RAG from a document
&gt; /createragfromdoc docs_rag ./documentation.md

# List all available RAGs
&gt; /listrag

# Query a RAG
&gt; /queryragfromdoc docs_rag &quot;How do I configure logging?&quot;

# Delete a RAG when no longer needed
&gt; /deleterag docs_rag
```

### File Management

Enhanced file operations:

```bash
# Show files in chat with details
&gt; /files
&gt; /files *.py  # Filter by pattern

# Show file statistics
&gt; /stats

# Enhanced add command with validation
&gt; /zadd file1.py file2.py

# Enhanced drop with confirmation
&gt; /zdrop file1.py
```

## Enhanced Git Integration

### Git Log and Status

```bash
# Show pretty git log with graphs
&gt; /glog
&gt; /glog -n 5  # Show last 5 commits
&gt; /glog --all  # Show all branches
&gt; /glog --stat  # Show file statistics

# Enhanced commit with statistics
&gt; /zcommit &quot;Added new feature&quot;
```

### Common Git Workflows

```bash
# Add files with status check
&gt; /zadd *.py

# Commit with automatic statistics
&gt; /zcommit

# Review changes
&gt; /glog --stat
```

## Custom Chat Features

### Using Keyword Substitution

1. Define keywords in `.aider.keywords.json`:
```json
{
    &quot;api&quot;: &quot;REST API with JSON responses&quot;,
    &quot;tests&quot;: &quot;Unit tests using pytest with mocking&quot;
}
```

2. Use in chat:
```bash
# Use keywords in messages
&gt; /customchat Create @text-tests for the login function

# Keywords will be expanded automatically
&gt; /customchat Add @text-api endpoint for user registration
```

### Context Management

```bash
# Save and view current chat context
&gt; /context_show

# Save a backup of the current chat context
&gt; /context_backup

# Load a previous chat context
&gt; /context_load

# Clear chat with history backup
&gt; /zclear
```

## Code Analysis Tools

### Code Explanation

```bash
# Get interactive explanation of code
&gt; /explain MyClass
&gt; /explain my_function --level=deep
&gt; /explain process_data --level=eli5
```

### Code Statistics

```bash
# Get detailed file statistics
&gt; /stats

# Show specific file details
&gt; /files mymodule.py
```

## Editor Integration

### Clipboard Integration

```bash
# Apply clipboard content as edits
&gt; /clip-edit myfile.py
```

### GUI Editors

```bash
# Launch Tkinter editor
&gt; /editor_tkinter
```

## Web and Voice Features

### Web Integration

```bash
# Enhanced web command with retry
&gt; /zweb https://example.com/docs

# Content is automatically saved to .extn_aider/temp/web/
```

### Voice Integration

```bash
# Enhanced voice command
&gt; /zvoice
# Speak your command
# Confirm accuracy when prompted
```

## AIChat API Integration

```bash
# Query a RAG using the aichat API
&gt; /aichat_rag_query aichat-wiki &quot;How does feature X work?&quot;
```

## Configuration

### Directory Structure

The extension creates these directories:
```
.extn_aider/
├── rags/        # RAG indexes
├── temp/
│   ├── context_backup/ # Context backups
│   ├── context/       # Context reports
│   ├── web/           # Scraped content
│   └── backups/       # File backups
└── explanations/# Code explanations
```

### Configuration Files

1. `.aider.conf.yml` - Main configuration:
```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree-only: true
```

2. `.extn_aider.keywords.json` - Custom keywords:
```json
{
    &quot;api&quot;: &quot;REST API with JSON responses&quot;,
    &quot;tests&quot;: &quot;Unit tests using pytest with mocking&quot;
}
```

## Tips and Tricks

### Keyboard Shortcuts

- `Ctrl+C` - Cancel current operation
- `Ctrl+D` - Exit Aider
- `Ctrl+S` - Save in editors
- `Esc` - Cancel in editors

### Efficiency Tips

1. Use command completion:
   ```bash
   # Press Tab to complete commands
   &gt; /cr&lt;Tab&gt;  # Completes to /createragfromdoc
   ```

2. Use patterns in file commands:
   ```bash
   &gt; /files *.py  # Show only Python files
   ```

3. Quick context check:
   ```bash
   &gt; /stats  # Quick overview of files
   ```

### Common Workflows

1. Document Analysis:
   ```bash
   &gt; /createragfromdoc docs docs.md
   &gt; /queryragfromdoc docs &quot;How to configure?&quot;
   ```

2. Code Review:
   ```bash
   &gt; /zadd *.py
   &gt; /stats
   &gt; /explain MainClass
   ```

3. Git Operations:
   ```bash
   &gt; /zadd modified_files.py
   &gt; /glog --stat
   &gt; /zcommit &quot;Updates&quot;
   ```

### Troubleshooting

1. Command not working:
   - Check if model is supported
   - Verify file paths are correct
   - Check for required dependencies

2. RAG issues:
   - Ensure document is text/markdown
   - Check document size is reasonable
   - Verify unique RAG nicknames

3. Editor issues:
   - Check for required packages
   - Verify clipboard content format
   - Check file permissions

### Best Practices

1. Regular backups:
   ```bash
   &gt; /context_backup  # Saves context regularly
   ```

2. Organized RAGs:
   ```bash
   &gt; /listrag  # Review existing RAGs
   &gt; /deleterag unused_rag  # Clean up
   ```

3. Efficient keyword use:
   - Keep keywords focused and clear
   - Update keywords as needed
   - Use descriptive expansions

4. Version control:
   ```bash
   &gt; /glog  # Regular status checks
   &gt; /zcommit  # Frequent small commits
   ```

````
</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>I updated the files.</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>Ok.</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>based on commands in commands folder of customaider, can you correct the command names and other details in README.md file</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>README.md
````
# Unofficial and experimental Aider Extension

Experimental Custom extensions for the Aider AI coding assistant.
The purpose of this repository is to experiment with possible new features and suggest to aider contributor to add based on their judgement.
Do not consider this in any way related to official distribution of aider.

## Important Notice

This is just for experimentation and not for serious use. If you want to use these files, 
please verify the code yourself and experiment with it before using it to any work.

## Features

- RAG (Retrieval Augmented Generation) support for document querying
- Advanced chat customization with keyword substitution
- Enhanced Git integration with better visualizations
- Code analysis and explanation tools
- Interactive context management and visualization
- GUI editors with syntax highlighting
- Web and voice command enhancements
- Template support for common development tasks

## Installation

```bash
# First install aider
pip install aider-chat

# Clone this repository
git clone https://github.com/YourUsername/aider-extension.git
cd aider-extension

# Install additional dependencies
pip install jinja2 llama-index-core llama-index-embeddings-huggingface pygments pyperclip streamlit requests
pip install &#39;aider-chat[help]&#39; --extra-index-url https://download.pytorch.org/whl/cpu
```

## Project Structure

```
./
├── main.py               # New simple runner
├── .extn_aider/           
│   ├── command_templates/ # Command templates
│   │   ├── load_templated/
│   │   └── load_templated_script/
│   └── All_Commands/     # Reference implementations (not used directly)
│       ├── docrag_commands/
│       ├── git_commands/
│       ├── context_commands/
│       └── ...
└── custom_aider/         # Core extension implementation
    ├── __init__.py
    ├── monkey_patch.py   # Early patching system
    ├── custom_aider_main.py
    ├── custom_coder.py
    ├── commands_registry.py
    ├── commands/         # Active command implementations
    │   ├── docrag_commands.py
    │   ├── git_commands.py
    │   └── ...
    ├── gui/             # GUI components
    └── docs/            # Documentation
```

## Basic Usage

1. Start the extended version:
```bash
python main.py
```

2. Use new commands in chat:
```
&gt; /help  # See available commands
&gt; /createragfromdoc docs ./documentation.md  # Create a RAG
&gt; /glog -n 5  # Show git history
```

## Available Commands

Note: For detailed documentation on each command, see the README.md files in `.extn_aider/All_Commands/*/`

### Document Processing
- `/createragfromdoc` - Create a RAG from document
- `/queryragfromdoc` - Query existing RAGs
- `/listrag` - List available RAGs
- `/deleterag` - Remove a RAG

### Enhanced Chat
- `/customchat` - Chat with keyword substitution
- `/clip-edit` - Apply clipboard edits
- `/editor_tkinter` - Launch desktop editor

### Git Integration
- `/glog` - Enhanced git log
- `/zadd` - Smart git add
- `/zcommit` - Enhanced commit with stats
- `/zdrop` - Enhanced drop with confirmation

### Context Management
- `/context_show` - Show chat context
- `/context_backup` - Backup chat context
- `/context_load` - Load chat context
- `/explain` - Interactive code explanation
- `/files` - List files with details
- `/stats` - Show file statistics
- `/zclear` - Enhanced clear with history backup

### Web and Voice
- `/zweb` - Enhanced web scraping with retry
- `/zvoice` - Enhanced voice command with retry

### Template Loading
- `/load_templated` - Load and execute parameterized command templates
- `/load_templated_script` - Load and execute script-based command templates

### AIChat API
- `/aichat_rag_query` - Query a RAG using the aichat API


## Configuration

1. Create `.aider.conf.yml`:
```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree-only: true
```

2. Create `.extn_aider.keywords.json` for chat substitutions:
```json
{
    &quot;api&quot;: &quot;REST API with JSON responses&quot;,
    &quot;tests&quot;: &quot;Unit tests using pytest&quot;
}
```

## Extension System Architecture

The extension system uses several key components:

1. **Command Registry** (`commands_registry.py`)
   - Central registration of commands
   - Manages completion handlers
   - Handles command help text

2. **Custom Coder** (`custom_coder.py`) 
   - Extends Aider&#39;s base Coder
   - Installs custom commands
   - Provides extension hooks

3. **Monkey Patching** (`monkey_patch.py`)
   - Early class patching
   - Safe core modifications
   - Path management

4. **Template Systems**
   - Command templates
   - Script templates 
   - Project scaffolding

For more technical details, see `custom_aider/docs/extension-docs.md`.

## Repository Organization 

- `.extn_aider/All_Commands/` contains reference implementations and documentation for each command type
- Active command implementations go in `custom_aider/commands/`
- GUI components in `custom_aider/gui/`
- Documentation in `custom_aider/docs/`

## Contributing

Feel free to experiment with these extensions and suggest improvements. This is an experimental project meant to explore potential new features for the Aider project.

## License

This project is licensed under the Apache License - see the LICENSE file for details.
````</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>I added these files to the chat: LICENSE, custom_aider/commands_registry.py, custom_aider/custom_aider_main.py, custom_aider/custom_coder.py, custom_aider/monkey_patch.py
Let me know if there are others we should add.</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>Okay, I understand.  I will only make changes to the files you&#39;ve explicitly added to the chat.  I will not make changes to any other files without your explicit permission.  Based on a review of the provided files, I don&#39;t see any necessary changes to `LICENSE`, `custom_aider/commands_registry.py`, `custom_aider/custom_aider_main.py`, or `custom_aider/monkey_patch.py` at this time.  They seem consistent with the command structure and functionality described in the updated `README.md`.
</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>APPLY CHANGES TO README.md</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>README.md
````
# Unofficial and experimental Aider Extension

Experimental Custom extensions for the Aider AI coding assistant.  This repository is for experimenting with potential new features and suggesting them to Aider contributors.  This is **not** an officially supported Aider distribution.

## Important Notice

This is purely experimental and not intended for production use.  Before using any code from this repository, please thoroughly review and test it.  Use at your own risk.

## Features

- **RAG (Retrieval Augmented Generation):**  Query documents using RAG.
- **Advanced Chat Customization:** Keyword substitution for enhanced chat interactions.
- **Enhanced Git Integration:** Improved visualizations and streamlined workflows.
- **Code Analysis and Explanation Tools:**  Interactive code analysis and explanation features.
- **Interactive Context Management:**  View, save, and load chat context.
- **GUI Editors:** Enhanced Tkinter editor with syntax highlighting and features.
- **Web and Voice Command Enhancements:** Improved web scraping and voice command processing.
- **Command Templating:** Create reusable command sequences using templates.


## Installation

1. **Install Aider:**
   ```bash
   pip install aider-chat
   ```

2. **Clone this repository:**
   ```bash
   git clone https://github.com/YourUsername/aider-extension.git
   cd aider-extension
   ```

3. **Install dependencies:**
   ```bash
   pip install jinja2 llama-index-core llama-index-embeddings-huggingface pygments pyperclip streamlit requests
   pip install &#39;aider-chat[help]&#39; --extra-index-url https://download.pytorch.org/whl/cpu
   ```

## Project Structure

```
./
├── main.py               # Main script to run the extension
├── .extn_aider/           # Directory for extension data
│   ├── command_templates/ # Directory for command templates
│   │   ├── load_templated/
│   │   └── load_templated_script/
│   └── ...
└── custom_aider/         # Core extension code
    ├── __init__.py
    ├── monkey_patch.py   # Early patching of Aider classes
    ├── custom_aider_main.py # Main entry point for the extension
    ├── custom_coder.py    # Custom Coder class
    ├── commands_registry.py # Command registry
    ├── commands/         # Custom command implementations
    │   ├── docrag_commands.py
    │   ├── git_commands.py
    │   └── ...
    ├── gui/             # GUI components (Tkinter editor)
    └── docs/            # Documentation
```

## Basic Usage

1. **Start the extension:**
   ```bash
   python main.py
   ```

2. **Use commands in the Aider chat:**
   ```
   &gt; /help  # List available commands
   &gt; /createragfromdoc docs ./documentation.md  # Create a RAG index
   &gt; /glog -n 5  # Show the last 5 git commits
   ```

## Available Commands

(See detailed documentation in the `custom_aider/docs` directory and individual command files.)

### Document Processing
- `/createragfromdoc &lt;nickname&gt; &lt;path&gt;`: Create a RAG index from a document.
- `/queryragfromdoc &lt;nickname&gt; &lt;query&gt;`: Query an existing RAG index.
- `/listrag`: List available RAG indexes.
- `/deleterag &lt;nickname&gt;`: Delete a RAG index.

### Enhanced Chat
- `/customchat &lt;message&gt;`: Send a message with keyword substitution.
- `/clip-edit &lt;filename&gt;`: Apply code edits from the clipboard.
- `/editor_tkinter`: Open the enhanced Tkinter editor.

### Git Integration
- `/glog [options]`: Show a Git log with graph and statistics.
- `/zadd &lt;files&gt;`: Add files to Git staging area with status check.
- `/zcommit &lt;message&gt;`: Commit changes with statistics in the message.
- `/zdrop &lt;files&gt;`: Remove files from the chat with backup.

### Context Management
- `/context_show`: Display the current chat context as HTML.
- `/context_backup [prefix]`: Save a backup of the chat context.
- `/context_load [filename]`: Load a chat context from a backup file.
- `/explain &lt;target&gt; [--level &lt;level&gt;]`: Get an interactive explanation of code.
- `/files [pattern]`: List files in the chat with details.
- `/stats`: Show statistics about files in the chat.
- `/zclear`: Clear the chat history with backup.

### Web and Voice
- `/zweb &lt;url&gt;`: Fetch content from a URL with retry mechanism.
- `/zvoice`: Use voice input with transcription confidence check.

### Template Loading
- `/load_templated &lt;template_name&gt;`: Load and execute a parameterized command template.
- `/load_templated_script &lt;template_name&gt;`: Load and execute a script-based command template.

### AIChat API
- `/aichat_rag_query &lt;rag_name&gt; &lt;query&gt;`: Query a RAG using the AIChat API.


## Configuration

1. **`.aider.conf.yml`:**  Main configuration file (see example below).
2. **`.extn_aider.keywords.json`:**  Keywords for chat substitution (see example below).

**Example `.aider.conf.yml`:**

```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree_only: true
```

**Example `.extn_aider.keywords.json`:**

```json
{
  &quot;api&quot;: &quot;REST API with JSON responses&quot;,
  &quot;tests&quot;: &quot;Unit tests using pytest&quot;
}
```

## Contributing

Contributions are welcome!  This is an experimental project, so feel free to experiment and suggest improvements.

## License

This project is licensed under the Apache License 2.0 - see the LICENSE file for details.
````</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>I updated the files.</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>Ok.</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>PLEASE ADD EXTENSION SYSTEM ARCHITECTURE OVERVIEW ALSO TO README.md</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>README.md
````
# Unofficial and experimental Aider Extension

Experimental Custom extensions for the Aider AI coding assistant.  This repository is for experimenting with potential new features and suggesting them to Aider contributors.  This is **not** an officially supported Aider distribution.

## Important Notice

This is purely experimental and not intended for production use.  Before using any code from this repository, please thoroughly review and test it.  Use at your own risk.

## Features

- **RAG (Retrieval Augmented Generation):**  Query documents using RAG.
- **Advanced Chat Customization:** Keyword substitution for enhanced chat interactions.
- **Enhanced Git Integration:** Improved visualizations and streamlined workflows.
- **Code Analysis and Explanation Tools:**  Interactive code analysis and explanation features.
- **Interactive Context Management:**  View, save, and load chat context.
- **GUI Editors:** Enhanced Tkinter editor with syntax highlighting and features.
- **Web and Voice Command Enhancements:** Improved web scraping and voice command processing.
- **Command Templating:** Create reusable command sequences using templates.


## Installation

1. **Install Aider:**
   ```bash
   pip install aider-chat
   ```

2. **Clone this repository:**
   ```bash
   git clone https://github.com/YourUsername/aider-extension.git
   cd aider-extension
   ```

3. **Install dependencies:**
   ```bash
   pip install jinja2 llama-index-core llama-index-embeddings-huggingface pygments pyperclip streamlit requests
   pip install &#39;aider-chat[help]&#39; --extra-index-url https://download.pytorch.org/whl/cpu
   ```

## Project Structure

```
./
├── main.py               # Main script to run the extension
├── .extn_aider/           # Directory for extension data
│   ├── command_templates/ # Directory for command templates
│   │   ├── load_templated/
│   │   └── load_templated_script/
│   └── ...
└── custom_aider/         # Core extension code
    ├── __init__.py
    ├── monkey_patch.py   # Early patching of Aider classes
    ├── custom_aider_main.py # Main entry point for the extension
    ├── custom_coder.py    # Custom Coder class
    ├── commands_registry.py # Command registry
    ├── commands/         # Custom command implementations
    │   ├── docrag_commands.py
    │   ├── git_commands.py
    │   └── ...
    ├── gui/             # GUI components (Tkinter editor)
    └── docs/            # Documentation
```

## Basic Usage

1. **Start the extension:**
   ```bash
   python main.py
   ```

2. **Use commands in the Aider chat:**
   ```
   &gt; /help  # List available commands
   &gt; /createragfromdoc docs ./documentation.md  # Create a RAG index
   &gt; /glog -n 5  # Show the last 5 git commits
   ```

## Available Commands

(See detailed documentation in the `custom_aider/docs` directory and individual command files.)

### Document Processing
- `/createragfromdoc &lt;nickname&gt; &lt;path&gt;`: Create a RAG index from a document.
- `/queryragfromdoc &lt;nickname&gt; &lt;query&gt;`: Query an existing RAG index.
- `/listrag`: List available RAG indexes.
- `/deleterag &lt;nickname&gt;`: Delete a RAG index.

### Enhanced Chat
- `/customchat &lt;message&gt;`: Send a message with keyword substitution.
- `/clip-edit &lt;filename&gt;`: Apply code edits from the clipboard.
- `/editor_tkinter`: Open the enhanced Tkinter editor.

### Git Integration
- `/glog [options]`: Show a Git log with graph and statistics.
- `/zadd &lt;files&gt;`: Add files to Git staging area with status check.
- `/zcommit &lt;message&gt;`: Commit changes with statistics in the message.
- `/zdrop &lt;files&gt;`: Remove files from the chat with backup.

### Context Management
- `/context_show`: Display the current chat context as HTML.
- `/context_backup [prefix]`: Save a backup of the chat context.
- `/context_load [filename]`: Load a chat context from a backup file.
- `/explain &lt;target&gt; [--level &lt;level&gt;]`: Get an interactive explanation of code.
- `/files [pattern]`: List files in the chat with details.
- `/stats`: Show statistics about files in the chat.
- `/zclear`: Clear the chat history with backup.

### Web and Voice
- `/zweb &lt;url&gt;`: Fetch content from a URL with retry mechanism.
- `/zvoice`: Use voice input with transcription confidence check.

### Template Loading
- `/load_templated &lt;template_name&gt;`: Load and execute a parameterized command template.
- `/load_templated_script &lt;template_name&gt;`: Load and execute a script-based command template.

### AIChat API
- `/aichat_rag_query &lt;rag_name&gt; &lt;query&gt;`: Query a RAG using the AIChat API.


## Configuration

1. **`.aider.conf.yml`:**  Main configuration file (see example below).
2. **`.extn_aider.keywords.json`:**  Keywords for chat substitution (see example below).

**Example `.aider.conf.yml`:**

```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree_only: true
```

**Example `.extn_aider.keywords.json`:**

```json
{
  &quot;api&quot;: &quot;REST API with JSON responses&quot;,
  &quot;tests&quot;: &quot;Unit tests using pytest&quot;
}
```

## Extension System Architecture

The extension system uses several key components:

1. **Command Registry** (`commands_registry.py`)
   - Central registration of commands
   - Manages completion handlers
   - Handles command help text

2. **Custom Coder** (`custom_coder.py`) 
   - Extends Aider&#39;s base Coder
   - Installs custom commands
   - Provides extension hooks

3. **Monkey Patching** (`monkey_patch.py`)
   - Early class patching
   - Safe core modifications
   - Path management

4. **Template Systems**
   - Command templates
   - Script templates 
   - Project scaffolding

For more technical details, see `custom_aider/docs/extension-docs.md`.

## Repository Organization 

- `.extn_aider/All_Commands/` contains reference implementations and documentation for each command type
- Active command implementations go in `custom_aider/commands/`
- GUI components in `custom_aider/gui/`
- Documentation in `custom_aider/docs/`

## Contributing

Feel free to experiment with these extensions and suggest improvements. This is an experimental project meant to explore potential new features for the Aider project.

## License

This project is licensed under the Apache License - see the LICENSE file for details.
````

</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>I updated the files.</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>Ok.</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>based on commands in commands folder of customaider, can you correct the command names and other details in extension-docs.md file</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>custom_aider/docs/extension-docs.md
````
# Aider Extension System Technical Documentation

This document explains how the Aider extension system works internally, providing technical details for developers who want to understand or extend the system.

## Overview

The extension system is built around several key components that work together to add new functionality to Aider:

1. Command Registry - Central registration and management of commands
2. Custom Coder - Enhanced coder class with extension support
3. Monkey Patching - System for safely extending Aider&#39;s core functionality
4. Dynamic Command Loading - Automatic discovery and loading of command modules

## Core Components

### 1. Commands Registry (`commands_registry.py`)

The `CommandsRegistry` is a central class that manages all custom commands:

```python
class CommandsRegistry:
    _commands: Dict[str, Callable] = {}
    _completions: Dict[str, Callable] = {}
    _descriptions: Dict[str, str] = {}

    @classmethod
    def register(cls, name: str, handler: Callable, completions: Optional[Callable] = None):
        # Registers a new command and its optional completions
        cmd_name = f&quot;cmd_{name}&quot;
        cls._commands[cmd_name] = handler
        if completions:
            cls._completions[f&quot;completions_{name}&quot;] = completions
```

Key features:
- Centralized command registration
- Support for command completions
- Automatic docstring extraction for help text
- Safe command installation checking

### 2. Custom Coder (`custom_coder.py`)

The `CustomCoder` extends Aider&#39;s base `Coder` class to support extensions:

```python
class CustomCoder(BaseCoder):
    _current_coder: ClassVar[Optional[&#39;CustomCoder&#39;]] = None
    
    @classmethod
    def create(cls, *args, **kwargs):
        coder = super().create(*args, **kwargs)
        if hasattr(coder, &#39;commands&#39;):
            CommandsRegistry.install_commands(coder.commands)
        cls._current_coder = coder
        return coder
```

Features:
- Maintains compatibility with base Aider functionality
- Installs custom commands on creation
- Provides extension points for new features

### 3. Monkey Patching (`monkey_patch.py`)

The monkey patching system allows safe modification of Aider&#39;s core classes:

```python
def monkey_patch_aider():
    # Add custom_aider directory to Python path
    custom_aider_dir = Path(__file__).parent
    if str(custom_aider_dir) not in sys.path:
        sys.path.insert(0, str(custom_aider_dir))
    
    # Patch Aider&#39;s coder classes
    from custom_aider.custom_coder import CustomCoder
    import aider.coders as coders
    coders.Coder = CustomCoder
```

Purpose:
- Ensures extensions are loaded before Aider&#39;s core
- Maintains consistent state across the application
- Provides clean integration points

## Command Implementation

### Command Structure

Each command module should follow this structure:

```python
from ..commands_registry import CommandsRegistry

def cmd_commandname(self, args):
    &quot;&quot;&quot;Command documentation
    Usage: /commandname &lt;args&gt;
    
    Detailed description of the command.
    &quot;&quot;&quot;
    # Command implementation
    pass

def completions_commandname(self):
    &quot;&quot;&quot;Return list of possible completions&quot;&quot;&quot;
    return [&quot;completion1&quot;, &quot;completion2&quot;]

# Register the command
CommandsRegistry.register(&quot;commandname&quot;, cmd_commandname, completions_commandname)
```

### Command Types

1. **Simple Commands**
   ```python
   def cmd_simple(self, args):
       self.io.tool_output(&quot;Simple command output&quot;)
   ```

2. **Interactive Commands**
   ```python
   def cmd_interactive(self, args):
       if self.io.confirm_ask(&quot;Continue?&quot;, default=&quot;y&quot;):
           # Perform action
           pass
   ```

3. **File-handling Commands**
   ```python
   def cmd_filehandler(self, args):
       for fname in self.coder.get_inchat_relative_files():
           path = Path(self.coder.abs_root_path(fname))
           # Process file
   ```

## Extension Initialization Flow

1. **Early Initialization**
   ```python
   # main.py
   from custom_aider.monkey_patch import monkey_patch_aider
   monkey_patch_aider()
   ```

2. **Command Loading**
   ```python
   def load_command_modules():
       commands_dir = Path(__file__).parent / &quot;commands&quot;
       for command_file in commands_dir.glob(&quot;*.py&quot;):
           if not command_file.name.startswith(&quot;_&quot;):
               importlib.import_module(f&quot;custom_aider.commands.{command_file.stem}&quot;)
   ```

3. **Command Installation**
   ```python
   def initialize_custom_aider():
       # Override Coder class
       import aider.coders as coders
       from .custom_coder import CustomCoder
       coders.Coder = CustomCoder
       
       # Load command modules
       load_command_modules()
   ```

## Adding New Commands

### 1. Create Command Module

Create a new Python file in the `commands` directory:

```python
# commands/my_command.py
from ..commands_registry import CommandsRegistry

def cmd_mycommand(self, args):
    &quot;&quot;&quot;My new command description
    Usage: /mycommand &lt;args&gt;
    &quot;&quot;&quot;
    # Implementation
    pass

CommandsRegistry.register(&quot;mycommand&quot;, cmd_mycommand)
```

### 2. Command Features

Commands can access:
- `self.coder` - The `CustomCoder` instance
- `self.io` - Input/output interface
- `self.coder.repo` - Git repository (if available)
- `self.coder.main_model` - Current language model

### 3. Best Practices

1. **Error Handling**
   ```python
   try:
       # Command logic
   except Exception as e:
       self.io.tool_error(f&quot;Error: {e}&quot;)
       return
   ```

2. **Input Validation**
   ```python
   if not args.strip():
       self.io.tool_error(&quot;Please provide required arguments&quot;)
       return
   ```

3. **Progress Feedback**
   ```python
   self.io.tool_output(&quot;Processing...&quot;)
   # Long operation
   self.io.tool_output(&quot;Done!&quot;)
   ```

## GUI Integration

The extension system supports multiple GUI frameworks:

### 1. Tkinter Integration
```python
class TkinterEditor:
    def __init__(self, initial_text=&quot;&quot;):
        self.root = tk.Tk()
        # Setup GUI
```

### 2. Streamlit Integration
```python
def create_streamlit_app():
    import streamlit as st
    # Define Streamlit interface
```

## Data Storage

Extensions can use these directories:

```python
STORAGE_PATHS = {
    &#39;rags&#39;: Path.home() / &#39;.aider&#39; / &#39;rags&#39;,
    &#39;context&#39;: Path.cwd() / &#39;.aider&#39; / &#39;context&#39;,
    &#39;web&#39;: Path.cwd() / &#39;.aider&#39; / &#39;web&#39;,
    &#39;backups&#39;: Path.home() / &#39;.aider&#39; / &#39;backups&#39;
}
```

Best practices for storage:
1. Use appropriate paths for global vs project data
2. Create directories as needed
3. Clean up temporary files
4. Handle storage errors gracefully

## Testing Extensions

### 1. Unit Testing Commands

```python
def test_command():
    coder = CustomCoder.create()
    result = coder.commands.cmd_mycommand(&quot;test args&quot;)
    assert result == expected_output
```

### 2. Integration Testing

```python
def test_extension_flow():
    initialize_custom_aider()
    # Test complete flow
```

## Debugging Tips

1. Enable debug output:
   ```python
   self.coder.verbose = True
   ```

2. Use logging:
   ```python
   import logging
   logger = logging.getLogger(__name__)
   logger.debug(&quot;Debug info&quot;)
   ```

3. Check command registration:
   ```python
   print(CommandsRegistry.list_commands())
   ```

## Common Issues and Solutions

1. **Command Not Found**
   - Check if command module is in the correct directory
   - Verify command registration syntax
   - Check for import errors in the module

2. **Completion Not Working**
   - Verify completion function is registered
   - Check completion function return value
   - Debug completion function logic

3. **GUI Issues**
   - Check required packages are installed
   - Verify GUI framework compatibility
   - Handle GUI events properly

## Best Practices Summary

1. Follow consistent command naming
2. Provide clear documentation
3. Handle errors gracefully
4. Give user feedback for long operations
5. Clean up resources properly
6. Test thoroughly
7. Log appropriately
8. Use appropriate storage locations
9. Validate inputs
10. Support command completion where appropriate

## Available Commands

This section provides a summary of the available commands within the extension.  For detailed usage instructions and examples, refer to the individual command files within the `custom_aider/commands` directory.

### Document Processing Commands
- `/createragfromdoc`: Create a RAG index from a document.
- `/queryragfromdoc`: Query an existing RAG index.
- `/listrag`: List available RAG indexes.
- `/deleterag`: Delete a RAG index.

### Enhanced Chat Commands
- `/customchat`: Send a message with keyword substitution.
- `/clip-edit`: Apply code edits from the clipboard.
- `/editor_tkinter`: Open the enhanced Tkinter editor.

### Git Integration Commands
- `/glog`: Show a Git log with graph and statistics.
- `/zadd`: Add files to Git staging area with status check.
- `/zcommit`: Commit changes with statistics in the message.
- `/zdrop`: Remove files from the chat with backup.

### Context Management Commands
- `/context_show`: Display the current chat context as HTML.
- `/context_backup`: Save a backup of the chat context.
- `/context_load`: Load a chat context from a backup file.
- `/explain`: Get an interactive explanation of code.
- `/files`: List files in the chat with details.
- `/stats`: Show statistics about files in the chat.
- `/zclear`: Clear the chat history with backup.

### Web and Voice Commands
- `/zweb`: Fetch content from a URL with retry mechanism.
- `/zvoice`: Use voice input with transcription confidence check.

### Template Loading Commands
- `/load_templated`: Load and execute a parameterized command template.
- `/load_templated_script`: Load and execute a script-based command template.

### AIChat API Commands
- `/aichat_rag_query`: Query a RAG using the AIChat API.

### Time Machine Command
- `/timemachine`: Explore code history intelligently.

### Utility Commands
- `/files`: List files with details.
- `/stats`: Show file statistics.

````
</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>I updated the files.</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>Ok.</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>please verify the file storage paths and other details once more and  correct the command names, storage paths and other details in extension-docs.md file</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>custom_aider/docs/extension-docs.md
````
# Aider Extension System Technical Documentation

This document explains how the Aider extension system works internally, providing technical details for developers who want to understand or extend the system.

## Overview

The extension system is built around several key components that work together to add new functionality to Aider:

1. Command Registry - Central registration and management of commands
2. Custom Coder - Enhanced coder class with extension support
3. Monkey Patching - System for safely extending Aider&#39;s core functionality
4. Dynamic Command Loading - Automatic discovery and loading of command modules

## Core Components

### 1. Commands Registry (`commands_registry.py`)

The `CommandsRegistry` is a central class that manages all custom commands:

```python
class CommandsRegistry:
    _commands: Dict[str, Callable] = {}
    _completions: Dict[str, Callable] = {}
    _descriptions: Dict[str, str] = {}

    @classmethod
    def register(cls, name: str, handler: Callable, completions: Optional[Callable] = None):
        # Registers a new command and its optional completions
        cmd_name = f&quot;cmd_{name}&quot;
        cls._commands[cmd_name] = handler
        if completions:
            cls._completions[f&quot;completions_{name}&quot;] = completions
```

Key features:
- Centralized command registration
- Support for command completions
- Automatic docstring extraction for help text
- Safe command installation checking

### 2. Custom Coder (`custom_coder.py`)

The `CustomCoder` extends Aider&#39;s base `Coder` class to support extensions:

```python
class CustomCoder(BaseCoder):
    _current_coder: ClassVar[Optional[&#39;CustomCoder&#39;]] = None
    
    @classmethod
    def create(cls, *args, **kwargs):
        coder = super().create(*args, **kwargs)
        if hasattr(coder, &#39;commands&#39;):
            CommandsRegistry.install_commands(coder.commands)
        cls._current_coder = coder
        return coder
```

Features:
- Maintains compatibility with base Aider functionality
- Installs custom commands on creation
- Provides extension points for new features

### 3. Monkey Patching (`monkey_patch.py`)

The monkey patching system allows safe modification of Aider&#39;s core classes:

```python
def monkey_patch_aider():
    # Add custom_aider directory to Python path
    custom_aider_dir = Path(__file__).parent
    if str(custom_aider_dir) not in sys.path:
        sys.path.insert(0, str(custom_aider_dir))
    
    # Patch Aider&#39;s coder classes
    from custom_aider.custom_coder import CustomCoder
    import aider.coders as coders
    coders.Coder = CustomCoder
```

Purpose:
- Ensures extensions are loaded before Aider&#39;s core
- Maintains consistent state across the application
- Provides clean integration points

## Command Implementation

### Command Structure

Each command module should follow this structure:

```python
from ..commands_registry import CommandsRegistry

def cmd_commandname(self, args):
    &quot;&quot;&quot;Command documentation
    Usage: /commandname &lt;args&gt;
    
    Detailed description of the command.
    &quot;&quot;&quot;
    # Command implementation
    pass

def completions_commandname(self):
    &quot;&quot;&quot;Return list of possible completions&quot;&quot;&quot;
    return [&quot;completion1&quot;, &quot;completion2&quot;]

# Register the command
CommandsRegistry.register(&quot;commandname&quot;, cmd_commandname, completions_commandname)
```

### Command Types

1. **Simple Commands**
   ```python
   def cmd_simple(self, args):
       self.io.tool_output(&quot;Simple command output&quot;)
   ```

2. **Interactive Commands**
   ```python
   def cmd_interactive(self, args):
       if self.io.confirm_ask(&quot;Continue?&quot;, default=&quot;y&quot;):
           # Perform action
           pass
   ```

3. **File-handling Commands**
   ```python
   def cmd_filehandler(self, args):
       for fname in self.coder.get_inchat_relative_files():
           path = Path(self.coder.abs_root_path(fname))
           # Process file
   ```

## Extension Initialization Flow

1. **Early Initialization**
   ```python
   # main.py
   from custom_aider.monkey_patch import monkey_patch_aider
   monkey_patch_aider()
   ```

2. **Command Loading**
   ```python
   def load_command_modules():
       commands_dir = Path(__file__).parent / &quot;commands&quot;
       for command_file in commands_dir.glob(&quot;*.py&quot;):
           if not command_file.name.startswith(&quot;_&quot;):
               importlib.import_module(f&quot;custom_aider.commands.{command_file.stem}&quot;)
   ```

3. **Command Installation**
   ```python
   def initialize_custom_aider():
       # Override Coder class
       import aider.coders as coders
       from .custom_coder import CustomCoder
       coders.Coder = CustomCoder
       
       # Load command modules
       load_command_modules()
   ```

## Adding New Commands

### 1. Create Command Module

Create a new Python file in the `commands` directory:

```python
# commands/my_command.py
from ..commands_registry import CommandsRegistry

def cmd_mycommand(self, args):
    &quot;&quot;&quot;My new command description
    Usage: /mycommand &lt;args&gt;
    &quot;&quot;&quot;
    # Implementation
    pass

CommandsRegistry.register(&quot;mycommand&quot;, cmd_mycommand)
```

### 2. Command Features

Commands can access:
- `self.coder` - The `CustomCoder` instance
- `self.io` - Input/output interface
- `self.coder.repo` - Git repository (if available)
- `self.coder.main_model` - Current language model

### 3. Best Practices

1. **Error Handling**
   ```python
   try:
       # Command logic
   except Exception as e:
       self.io.tool_error(f&quot;Error: {e}&quot;)
       return
   ```

2. **Input Validation**
   ```python
   if not args.strip():
       self.io.tool_error(&quot;Please provide required arguments&quot;)
       return
   ```

3. **Progress Feedback**
   ```python
   self.io.tool_output(&quot;Processing...&quot;)
   # Long operation
   self.io.tool_output(&quot;Done!&quot;)
   ```

## GUI Integration

The extension system supports multiple GUI frameworks:

### 1. Tkinter Integration
```python
class TkinterEditor:
    def __init__(self, initial_text=&quot;&quot;):
        self.root = tk.Tk()
        # Setup GUI
```

### 2. Streamlit Integration
```python
def create_streamlit_app():
    import streamlit as st
    # Define Streamlit interface
```

## Data Storage

The extension uses the following directories for data storage:

- **`.extn_aider/rags/`**: Stores RAG (Retrieval Augmented Generation) indexes.  Each RAG is stored in its own subdirectory within this folder, named after the RAG&#39;s nickname.
- **`.extn_aider/temp/context_backup/`**: Stores backups of the chat context.  Backups are saved as JSON files with timestamps in the filename.
- **`.extn_aider/temp/context/`**: Stores HTML files generated by the `/context_create` command.
- **`.extn_aider/temp/web/`**: Stores content scraped from URLs using the `/zweb` command.
- **`.extn_aider/temp/backups/`**: Stores backups of files dropped from the chat using the `/zdrop` command.
- **`.extn_aider/explanations/`**: Stores code explanations generated by the `/explain` command.
- **`.extn_aider/command_templates/load_templated/`**: Stores JSON-based command templates for the `/load_templated` command.
- **`.extn_aider/command_templates/load_templated_script/`**: Stores Python script-based command templates for the `/load_templated_script` command.


Best practices for storage:
1. Use appropriate paths for global vs project data
2. Create directories as needed
3. Clean up temporary files
4. Handle storage errors gracefully

## Testing Extensions

### 1. Unit Testing Commands

```python
def test_command():
    coder = CustomCoder.create()
    result = coder.commands.cmd_mycommand(&quot;test args&quot;)
    assert result == expected_output
```

### 2. Integration Testing

```python
def test_extension_flow():
    initialize_custom_aider()
    # Test complete flow
```

## Debugging Tips

1. Enable debug output:
   ```python
   self.coder.verbose = True
   ```

2. Use logging:
   ```python
   import logging
   logger = logging.getLogger(__name__)
   logger.debug(&quot;Debug info&quot;)
   ```

3. Check command registration:
   ```python
   print(CommandsRegistry.list_commands())
   ```

## Common Issues and Solutions

1. **Command Not Found**
   - Check if command module is in the correct directory
   - Verify command registration syntax
   - Check for import errors in the module

2. **Completion Not Working**
   - Verify completion function is registered
   - Check completion function return value
   - Debug completion function logic

3. **GUI Issues**
   - Check required packages are installed
   - Verify GUI framework compatibility
   - Handle GUI events properly

## Best Practices Summary

1. Follow consistent command naming
2. Provide clear documentation
3. Handle errors gracefully
4. Give user feedback for long operations
5. Clean up resources properly
6. Test thoroughly
7. Log appropriately
8. Use appropriate storage locations
9. Validate inputs
10. Support command completion where appropriate

## Available Commands

This section provides a summary of the available commands within the extension.  For detailed usage instructions and examples, refer to the individual command files within the `custom_aider/commands` directory.

### Document Processing Commands
- `/createragfromdoc`: Create a RAG index from a document.
- `/queryragfromdoc`: Query an existing RAG index.
- `/listrag`: List available RAG indexes.
- `/deleterag`: Delete a RAG index.

### Enhanced Chat Commands
- `/customchat`: Send a message with keyword substitution.
- `/clip-edit`: Apply code edits from the clipboard.
- `/editor_tkinter`: Open the enhanced Tkinter editor.

### Git Integration Commands
- `/glog`: Show a Git log with graph and statistics.
- `/zadd`: Add files to Git staging area with status check.
- `/zcommit`: Commit changes with statistics in the message.
- `/zdrop`: Remove files from the chat with backup.

### Context Management Commands
- `/context_show`: Display the current chat context as HTML.
- `/context_backup`: Save a backup of the chat context.
- `/context_load`: Load a chat context from a backup file.
- `/context_create`: Create an interactive context view with export capabilities.

### Web and Voice Commands
- `/zweb`: Fetch content from a URL with retry mechanism.
- `/zvoice`: Use voice input with transcription confidence check.

### Template Loading Commands
- `/load_templated`: Load and execute a parameterized command template.
- `/load_templated_script`: Load and execute a script-based command template.

### AIChat API Commands
- `/aichat_rag_query`: Query a RAG using the AIChat API.

### Time Machine Command
- `/timemachine`: Explore code history intelligently.

### Utility Commands
- `/files`: List files with details.
- `/stats`: Show file statistics.

````
</pre>
</div>
<div class="user-message chat-message">
<strong>USER</strong>
<pre>I updated the files.</pre>
</div>
<div class="assistant-message chat-message">
<strong>ASSISTANT</strong>
<pre>Ok.</pre>
</div>

</div>
<div class="section">
<h2>File Contents</h2>
<h3>LICENSE</h3>
<div class="file-content">
<pre>                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      &quot;License&quot; shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      &quot;Legal Entity&quot; shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      &quot;control&quot; means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      &quot;Source&quot; form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      &quot;Object&quot; form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      &quot;Work&quot; shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      &quot;Contribution&quot; shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, &quot;submitted&quot;
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as &quot;Not a Contribution.&quot;

      &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets &quot;[]&quot;
      replaced with your own identifying information. (Don&#39;t include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same &quot;printed page&quot; as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</pre>
</div>
<h3>README.md</h3>
<div class="file-content">
<pre># Unofficial and experimental Aider Extension

Experimental Custom extensions for the Aider AI coding assistant.  This repository is for experimenting with potential new features and suggesting them to Aider contributors.  This is **not** an officially supported Aider distribution.

## Important Notice

This is purely experimental and not intended for production use.  Before using any code from this repository, please thoroughly review and test it.  Use at your own risk.

## Features

- **RAG (Retrieval Augmented Generation):**  Query documents using RAG.
- **Advanced Chat Customization:** Keyword substitution for enhanced chat interactions.
- **Enhanced Git Integration:** Improved visualizations and streamlined workflows.
- **Code Analysis and Explanation Tools:**  Interactive code analysis and explanation features.
- **Interactive Context Management:**  View, save, and load chat context.
- **GUI Editors:** Enhanced Tkinter editor with syntax highlighting and features.
- **Web and Voice Command Enhancements:** Improved web scraping and voice command processing.
- **Command Templating:** Create reusable command sequences using templates.


## Installation

1. **Install Aider:**
   ```bash
   pip install aider-chat
   ```

2. **Clone this repository:**
   ```bash
   git clone https://github.com/YourUsername/aider-extension.git
   cd aider-extension
   ```

3. **Install dependencies:**
   ```bash
   pip install jinja2 llama-index-core llama-index-embeddings-huggingface pygments pyperclip streamlit requests
   pip install &#39;aider-chat[help]&#39; --extra-index-url https://download.pytorch.org/whl/cpu
   ```

## Project Structure

```
./
├── main.py               # Main script to run the extension
├── .extn_aider/           # Directory for extension data
│   ├── command_templates/ # Directory for command templates
│   │   ├── load_templated/
│   │   └── load_templated_script/
│   └── ...
└── custom_aider/         # Core extension code
    ├── __init__.py
    ├── monkey_patch.py   # Early patching of Aider classes
    ├── custom_aider_main.py # Main entry point for the extension
    ├── custom_coder.py    # Custom Coder class
    ├── commands_registry.py # Command registry
    ├── commands/         # Custom command implementations
    │   ├── docrag_commands.py
    │   ├── git_commands.py
    │   └── ...
    ├── gui/             # GUI components (Tkinter editor)
    └── docs/            # Documentation
```

## Basic Usage

1. **Start the extension:**
   ```bash
   python main.py
   ```

2. **Use commands in the Aider chat:**
   ```
   &gt; /help  # List available commands
   &gt; /createragfromdoc docs ./documentation.md  # Create a RAG index
   &gt; /glog -n 5  # Show the last 5 git commits
   ```

## Available Commands

(See detailed documentation in the `custom_aider/docs` directory and individual command files.)

### Document Processing
- `/createragfromdoc &lt;nickname&gt; &lt;path&gt;`: Create a RAG index from a document.
- `/queryragfromdoc &lt;nickname&gt; &lt;query&gt;`: Query an existing RAG index.
- `/listrag`: List available RAG indexes.
- `/deleterag &lt;nickname&gt;`: Delete a RAG index.

### Enhanced Chat
- `/customchat &lt;message&gt;`: Send a message with keyword substitution.
- `/clip-edit &lt;filename&gt;`: Apply code edits from the clipboard.
- `/editor_tkinter`: Open the enhanced Tkinter editor.

### Git Integration
- `/glog [options]`: Show a Git log with graph and statistics.
- `/zadd &lt;files&gt;`: Add files to Git staging area with status check.
- `/zcommit &lt;message&gt;`: Commit changes with statistics in the message.
- `/zdrop &lt;files&gt;`: Remove files from the chat with backup.

### Context Management
- `/context_show`: Display the current chat context as HTML.
- `/context_backup [prefix]`: Save a backup of the chat context.
- `/context_load [filename]`: Load a chat context from a backup file.
- `/explain &lt;target&gt; [--level &lt;level&gt;]`: Get an interactive explanation of code.
- `/files [pattern]`: List files in the chat with details.
- `/stats`: Show statistics about files in the chat.
- `/zclear`: Clear the chat history with backup.

### Web and Voice
- `/zweb &lt;url&gt;`: Fetch content from a URL with retry mechanism.
- `/zvoice`: Use voice input with transcription confidence check.

### Template Loading
- `/load_templated &lt;template_name&gt;`: Load and execute a parameterized command template.
- `/load_templated_script &lt;template_name&gt;`: Load and execute a script-based command template.

### AIChat API
- `/aichat_rag_query &lt;rag_name&gt; &lt;query&gt;`: Query a RAG using the AIChat API.


## Configuration

1. **`.aider.conf.yml`:**  Main configuration file (see example below).
2. **`.extn_aider.keywords.json`:**  Keywords for chat substitution (see example below).

**Example `.aider.conf.yml`:**

```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree_only: true
```

**Example `.extn_aider.keywords.json`:**

```json
{
  &quot;api&quot;: &quot;REST API with JSON responses&quot;,
  &quot;tests&quot;: &quot;Unit tests using pytest&quot;
}
```

## Extension System Architecture

The extension system uses several key components:

1. **Command Registry** (`commands_registry.py`)
   - Central registration of commands
   - Manages completion handlers
   - Handles command help text

2. **Custom Coder** (`custom_coder.py`) 
   - Extends Aider&#39;s base Coder
   - Installs custom commands
   - Provides extension hooks

3. **Monkey Patching** (`monkey_patch.py`)
   - Early class patching
   - Safe core modifications
   - Path management

4. **Template Systems**
   - Command templates
   - Script templates 
   - Project scaffolding

For more technical details, see `custom_aider/docs/extension-docs.md`.

## Repository Organization 

- `.extn_aider/All_Commands/` contains reference implementations and documentation for each command type
- Active command implementations go in `custom_aider/commands/`
- GUI components in `custom_aider/gui/`
- Documentation in `custom_aider/docs/`

## Contributing

Feel free to experiment with these extensions and suggest improvements. This is an experimental project meant to explore potential new features for the Aider project.

## License

This project is licensed under the Apache License - see the LICENSE file for details.
</pre>
</div>
<h3>custom_aider/commands/__init__.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;
Custom command modules for aider extension
&quot;&quot;&quot;</pre>
</div>
<h3>custom_aider/commands/aichat_commands.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Commands for interacting with aichat API endpoints&quot;&quot;&quot;

import requests
import json
from ..commands_registry import CommandsRegistry

def cmd_aichat_rag_query(self, args):
    &quot;&quot;&quot;Query a RAG using the aichat API endpoint
    Usage: /query_rag_from_aichat &lt;rag_name&gt; &lt;query&gt;
    
    Searches the specified RAG for content relevant to your query
    using the aichat RAG search API endpoint.
    
    Example:
        /query_rag_from_aichat aichat-wiki &quot;How does feature X work?&quot;
    &quot;&quot;&quot;
    # Parse arguments
    parts = args.strip().split(maxsplit=1)
    if len(parts) != 2:
        self.io.tool_error(&quot;Usage: /query_rag_from_aichat &lt;rag_name&gt; &lt;query&gt;&quot;)
        return
        
    rag_name, query = parts
    
    # Prepare request
    url = &quot;http://localhost:8000/v1/rags/search&quot;
    headers = {
        &quot;Content-Type&quot;: &quot;application/json&quot;,
        &quot;Accept&quot;: &quot;application/json&quot;
    }
    payload = {
        &quot;name&quot;: rag_name,
        &quot;input&quot;: query
    }
    
    # Make request
    try:
        self.io.tool_output(f&quot;Querying RAG &#39;{rag_name}&#39;...&quot;)
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()
        
        # Extract response data
        result = response.json()
        if &quot;data&quot; not in result:
            raise ValueError(&quot;Unexpected response format - missing &#39;data&#39; field&quot;)
            
        # Format output
        context_data = result[&quot;data&quot;]
        
        # Extract context from the response
        # The context is wrapped in &lt;context&gt; tags in the response
        import re
        context_match = re.search(r&quot;&lt;context&gt;(.*?)&lt;/context&gt;&quot;, context_data, re.DOTALL)
        if not context_match:
            raise ValueError(&quot;No context found in response&quot;)
            
        context = context_match.group(1).strip()
        
        # Format the output
        output = [
            f&quot;\nResults from aichat RAG &#39;{rag_name}&#39;:&quot;,
            f&quot;\nQuery: {query}\n&quot;,
            &quot;Context:&quot;,
            context,
            &quot;\n--- End of results ---&quot;
        ]
        
        formatted_output = &quot;\n&quot;.join(output)
        
        # Display results
        self.io.tool_output(formatted_output)
        
        # Add to chat context
        self.coder.cur_messages += [
            dict(role=&quot;user&quot;, content=formatted_output),
            dict(role=&quot;assistant&quot;, content=&quot;Ok.&quot;),
        ]
        
    except requests.exceptions.ConnectionError:
        self.io.tool_error(&quot;Could not connect to aichat API. Is the server running?&quot;)
    except requests.exceptions.HTTPError as e:
        self.io.tool_error(f&quot;API request failed: {e}&quot;)
    except ValueError as e:
        self.io.tool_error(f&quot;Error processing response: {e}&quot;)
    except Exception as e:
        self.io.tool_error(f&quot;Error querying RAG: {e}&quot;)

def completions_aichat_rag_query(self):
    &quot;&quot;&quot;Completions for query_rag_from_aichat command&quot;&quot;&quot;
    # Return basic defaults since the aichat example doesn&#39;t show 
    # a RAG listing endpoint
    return [&quot;aichat-wiki&quot;, &quot;temp&quot;]

# Register the command
CommandsRegistry.register(
    &quot;aichat_rag_query&quot;, 
    cmd_aichat_rag_query,
    completions_aichat_rag_query
)
</pre>
</div>
<h3>custom_aider/commands/clip_edit_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Startup script that adds clipboard edit command&quot;&quot;&quot;
import pyperclip
from pathlib import Path

from ..commands_registry import CommandsRegistry

&quot;&quot;&quot;Add clipboard edit command to Aider&quot;&quot;&quot;
def cmd_clip_edit(self, args):
    &quot;&quot;&quot;Apply clipboard contents as edits to specified files
    Usage: /clip-edit &lt;filename&gt;
    
    Gets code edits from clipboard (copied from ChatGPT/Claude) and applies them to the specified file.
    The clipboard content should contain code changes in a supported format (diff, whole file, etc).
    &quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please specify a file to edit&quot;)
        return
        
    # Get clipboard content
    try:
        content = pyperclip.paste()
        if not content:
            self.io.tool_error(&quot;No content found in clipboard&quot;)
            return
    except Exception as e:
        self.io.tool_error(f&quot;Error accessing clipboard: {e}&quot;)
        return
        
    target_file = args.strip()
    
    # Add file to chat if not already present
    if target_file not in self.coder.get_inchat_relative_files():
        self.cmd_add(target_file)
        if target_file not in self.coder.get_inchat_relative_files():
            return # Add failed
            
    # Set up for applying edits
    self.coder.partial_response_content = content
    
    try:
        # Try applying the edits
        edited = self.coder.apply_updates()
        
        if edited:
            self.io.tool_output(f&quot;Applied clipboard edits to {&#39;, &#39;.join(edited)}&quot;)
            
            # Auto-commit if enabled
            if self.coder.auto_commits and self.coder.repo:
                commit_msg = f&quot;Applied clipboard edits to {&#39;, &#39;.join(edited)}&quot;
                self.coder.repo.commit(
                    fnames=edited,
                    message=commit_msg,
                    aider_edits=True
                )
        else:
            self.io.tool_error(&quot;No edits were applied. Check that the clipboard contains valid code changes.&quot;)
            
    except ValueError as e:
        # Handle format errors
        self.io.tool_error(f&quot;Error applying edits: {e}&quot;)
        self.io.tool_output(
            &quot;Make sure the clipboard contains code changes in a supported format &quot;
            &quot;(diff, whole file, etc)&quot;
        )
        

# Add command completion
def completions_clip_edit(self):
    &quot;&quot;&quot;Provide file completion for clip-edit command&quot;&quot;&quot;
    return self.completions_add()
    
CommandsRegistry.register(&quot;clip_edit&quot;, cmd_clip_edit, completions_clip_edit)</pre>
</div>
<h3>custom_aider/commands/context_backup_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for saving a backup copy of current chat context in JSON format&quot;&quot;&quot;

import json
from datetime import datetime
from pathlib import Path

from ..commands_registry import CommandsRegistry

def cmd_context_backup(self, args):
    &quot;&quot;&quot;Save a backup copy of current chat context in JSON format
    Usage: /context_backup [filename_prefix]
    
    Saves the current chat context including model info, files, and messages
    as a JSON file in .extn_aider/temp/context_backup/ directory.
    Optional filename prefix can be specified.
    &quot;&quot;&quot;
    # Create backup directory
    backup_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;temp&#39; / &#39;context_backup&#39;
    backup_dir.mkdir(parents=True, exist_ok=True)

    # Generate timestamp
    timestamp = datetime.now().strftime(&#39;%Y-%m-%d_%H_%M_%S&#39;)

    # Use provided prefix or default
    prefix = args.strip() if args else &quot;aider_context&quot;
    filename = f&quot;{prefix}_{timestamp}.json&quot;
    backup_file = backup_dir / filename

    try:
        # Gather context data
        context_data = {
            &quot;timestamp&quot;: datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;),
            &quot;model&quot;: self.coder.main_model.name,
            &quot;files&quot;: list(self.coder.get_inchat_relative_files()),
            &quot;messages&quot;: self.coder.done_messages + self.coder.cur_messages
        }

        # Save to JSON file
        with open(backup_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            json.dump(context_data, f, indent=2, ensure_ascii=False)

        self.io.tool_output(f&quot;\nSaved context backup to {backup_file}&quot;)

    except Exception as e:
        self.io.tool_error(f&quot;Error saving context backup: {e}&quot;)

# Register the command
CommandsRegistry.register(&quot;context_backup&quot;, cmd_context_backup)
</pre>
</div>
<h3>custom_aider/commands/context_create_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for interactive context viewing and export&quot;&quot;&quot;

import os
import json
import webbrowser
from datetime import datetime
from pathlib import Path
from jinja2 import Template

from ..commands_registry import CommandsRegistry

# Get template directory
TEMPLATE_DIR = Path(__file__).parent.parent / &#39;gui&#39; / &#39;templates&#39; / &#39;cmd_context_create_tmpl&#39;

def get_context_data(coder):
    &quot;&quot;&quot;Gather all context data&quot;&quot;&quot;
    context_data = {
        &#39;timestamp&#39;: datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;),
        &#39;model_info&#39;: {
            &#39;name&#39;: coder.main_model.name,
            &#39;edit_format&#39;: coder.edit_format
        },
        &#39;files&#39;: [],
        &#39;messages&#39;: [],
        &#39;git_info&#39;: None
    }
    
    # Get file information
    for fname in coder.get_inchat_relative_files():
        try:
            path = Path(coder.abs_root_path(fname))
            if path.exists():
                content = path.read_text()
                context_data[&#39;files&#39;].append({
                    &#39;name&#39;: fname,
                    &#39;size&#39;: path.stat().st_size,
                    &#39;lines&#39;: len(content.splitlines()),
                    &#39;content&#39;: content
                })
        except Exception:
            continue
            
    # Get chat messages
    messages = (coder.done_messages + coder.cur_messages)
    for msg in messages:
        context_data[&#39;messages&#39;].append({
            &#39;role&#39;: msg.get(&#39;role&#39;, &#39;&#39;),
            &#39;content&#39;: msg.get(&#39;content&#39;, &#39;&#39;)
        })
        
    # Get git info if available
    if coder.repo:
        try:
            repo = coder.repo.repo
            branch = repo.active_branch.name
            commit = repo.head.commit
            context_data[&#39;git_info&#39;] = {
                &#39;branch&#39;: branch,
                &#39;commit_hash&#39;: commit.hexsha[:7],
                &#39;author&#39;: str(commit.author),
                &#39;date&#39;: str(commit.committed_datetime)
            }
        except Exception:
            pass
            
    return context_data

def cmd_context_create(self, args):
    &quot;&quot;&quot;Create interactive context view with export capabilities
    Usage: /context_create
    
    Generates an HTML page showing all context elements:
    - Files in chat
    - Chat messages
    - Model information
    - Git status
    
    Features:
    - Checkbox to select/unselect items
    - Export selected items as JSON
    - Interactive expanding/collapsing sections
    &quot;&quot;&quot;
    try:
        # Get context data
        context_data = get_context_data(self.coder)
        
        # Load template files
        with open(TEMPLATE_DIR / &#39;base_template.html&#39;) as f:
            template = Template(f.read())
            
        with open(TEMPLATE_DIR / &#39;style.css&#39;) as f:
            styles = f.read()
            
        with open(TEMPLATE_DIR / &#39;script.js&#39;) as f:
            scripts = f.read()
            
        # Generate HTML
        html = template.render(
            context=context_data,
            styles=styles,
            scripts=scripts
        )
        
        # Save the file
        output_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;context&#39;
        output_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime(&#39;%Y%m%d_%H%M%S&#39;)
        output_file = output_dir / f&#39;context_view_{timestamp}.html&#39;
        output_file.write_text(html, encoding=&#39;utf-8&#39;)
        
        self.io.tool_output(f&quot;\nSaved context view to {output_file}&quot;)
        
        # Open in browser
        try:
            webbrowser.open(output_file.as_uri())
            self.io.tool_output(&quot;Opened in default browser&quot;)
        except Exception as e:
            self.io.tool_error(f&quot;Error opening browser: {e}&quot;)
            self.io.tool_output(f&quot;You can manually open: {output_file}&quot;)
            
    except Exception as e:
        self.io.tool_error(f&quot;Error creating context view: {e}&quot;)

# Register the command
CommandsRegistry.register(&quot;context_create&quot;, cmd_context_create)</pre>
</div>
<h3>custom_aider/commands/context_load_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for restoring chat context from a backup file&quot;&quot;&quot;

import json
from datetime import datetime
from pathlib import Path
import os

from ..commands_registry import CommandsRegistry

def _list_context_files():
    &quot;&quot;&quot;List all context files in backup and create directories&quot;&quot;&quot;
    context_files = []
    
    # Check both backup and create directories
    for dirname in [&#39;context_backup&#39;, &#39;context_create&#39;]:
        context_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;temp&#39; / dirname
        if context_dir.exists():
            context_files.extend(context_dir.glob(&#39;*.json&#39;))
            
    return sorted(context_files)

def _load_context_file(filepath):
    &quot;&quot;&quot;Load and validate context file&quot;&quot;&quot;
    try:
        with open(filepath, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            data = json.load(f)
            
        # Validate required fields
        required_fields = [&#39;timestamp&#39;, &#39;model&#39;, &#39;files&#39;, &#39;messages&#39;]
        if not all(field in data for field in required_fields):
            raise ValueError(&quot;Missing required fields in context file&quot;)
            
        return data
    except Exception as e:
        raise ValueError(f&quot;Error loading context file: {e}&quot;)

def cmd_context_load(self, args):
    &quot;&quot;&quot;Load a context from a backup file
    Usage: /context_load [filename]
    
    If filename is not provided, lists available context files.
    First clears current context, then loads files and messages from the context file.
    Searches in both .extn_aider/temp/context_backup/ and .extn_aider/temp/context_create/ directories.
    &quot;&quot;&quot;
    # List context files if no argument provided
    if not args.strip():
        context_files = _list_context_files()
        if not context_files:
            self.io.tool_error(&quot;No context files found in .extn_aider/temp/context_backup/ or .extn_aider/temp/context_create/&quot;)
            return
            
        self.io.tool_output(&quot;\nAvailable context files:&quot;)
        for file in context_files:
            file_time = datetime.fromtimestamp(file.stat().st_mtime).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
            self.io.tool_output(f&quot;  {file.name} (Last modified: {file_time})&quot;)
        return

    # Find the specified file
    filename = args.strip()
    context_file = None
    
    for dirname in [&#39;context_backup&#39;, &#39;context_create&#39;]:
        path = Path.cwd() / &#39;.extn_aider&#39; / &#39;temp&#39; / dirname / filename
        if path.exists():
            context_file = path
            break
            
    if not context_file:
        self.io.tool_error(f&quot;Context file not found: {filename}&quot;)
        return

    try:
        # Load and validate context file
        context_data = _load_context_file(context_file)
        
        # Clear current context and files
        self.cmd_reset(&quot;&quot;)
        
        # Add files from context
        files_to_add = []
        for file in context_data[&#39;files&#39;]:
            file_path = Path(self.coder.abs_root_path(file))
            if file_path.exists():
                files_to_add.append(file)
            else:
                self.io.tool_warning(f&quot;File not found: {file}&quot;)
                
        if files_to_add:
            self.cmd_add(&quot; &quot;.join(files_to_add))
            
        # Add messages to context
        self.coder.done_messages.extend(context_data[&#39;messages&#39;])
        
        # Report success
        self.io.tool_output(f&quot;\nLoaded context from {context_file}&quot;)
        self.io.tool_output(f&quot;Model: {context_data[&#39;model&#39;]}&quot;)
        self.io.tool_output(f&quot;Timestamp: {context_data[&#39;timestamp&#39;]}&quot;)
        self.io.tool_output(f&quot;Added {len(files_to_add)} files&quot;)
        self.io.tool_output(f&quot;Added {len(context_data[&#39;messages&#39;])} messages&quot;)
        
    except Exception as e:
        self.io.tool_error(f&quot;Error loading context: {e}&quot;)

def completions_context_load(self):
    &quot;&quot;&quot;Provide completions for context_load command - available context files&quot;&quot;&quot;
    try:
        return [f.name for f in _list_context_files()]
    except:
        return []

# Register the command
CommandsRegistry.register(&quot;context_load&quot;, cmd_context_load, completions_context_load)
</pre>
</div>
<h3>custom_aider/commands/context_show_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Commands for showing and saving context information&quot;&quot;&quot;

import time
import webbrowser
from datetime import datetime
from pathlib import Path

from ..commands_registry import CommandsRegistry

HTML_TEMPLATE = r&quot;&quot;&quot;&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Aider Chat Context - {timestamp}&lt;/title&gt;
&lt;style&gt;
body {{ font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, sans-serif; line-height: 1.6; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; color: #333; }}
.container {{ background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }}
.header {{ border-bottom: 2px solid #eee; margin-bottom: 20px; padding-bottom: 10px; }}
.section {{ margin-bottom: 30px; }}
.file-content {{ background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; font-family: &quot;Consolas&quot;, &quot;Monaco&quot;, monospace; }}
.chat-message {{ margin: 10px 0; padding: 10px; border-radius: 5px; }}
.user-message {{ background: #e3f2fd; border-left: 4px solid #2196f3; }}
.assistant-message {{ background: #f5f5f5; border-left: 4px solid #9e9e9e; }}
.system-message {{ background: #fff3e0; border-left: 4px solid #ff9800; }}
.repo-map {{ background: #f1f8e9; border-left: 4px solid #8bc34a; }}
pre {{ margin: 0; padding: 10px; overflow-x: auto; }}
.metadata {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 20px; }}
.metadata-item {{ background: #fff; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }}
.file-list {{ list-style: none; padding: 0; }}
.file-list li {{ padding: 5px 0; }}
.stats {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
{content}
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&quot;&quot;&quot;

def escape_html(text):
    &quot;&quot;&quot;Escape HTML special characters to their HTML entities&quot;&quot;&quot;
    return (str(text)
            .replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
            .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
            .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
            .replace(&#39;&quot;&#39;, &quot;&amp;quot;&quot;)
            .replace(&quot;&#39;&quot;, &quot;&amp;#39;&quot;))

def format_messages(messages):
    &quot;&quot;&quot;Format chat messages into HTML with proper escaping&quot;&quot;&quot;
    html = &quot;&quot;
    for msg in messages:
        role = msg.get(&#39;role&#39;, &#39;&#39;)
        content = msg.get(&#39;content&#39;, &#39;&#39;)
        
        # Skip empty messages
        if not content:
            continue
            
        css_class = f&quot;{role}-message chat-message&quot;
        
        # Special handling for system messages that look like part of the repo map
        if role == &quot;user&quot; and &quot;Here are summaries of some files present in my git repo&quot; in content:
            css_class = &quot;repo-map chat-message&quot;
        
        html += f&#39;&lt;div class=&quot;{escape_html(css_class)}&quot;&gt;\n&#39;
        html += f&#39;&lt;strong&gt;{escape_html(role.upper())}&lt;/strong&gt;\n&#39;
        html += f&#39;&lt;pre&gt;{escape_html(content)}&lt;/pre&gt;\n&#39;
        html += &#39;&lt;/div&gt;\n&#39;
        
    return html

def get_file_stats(coder):
    &quot;&quot;&quot;Get statistics about files in chat&quot;&quot;&quot;
    stats = {&#39;total_files&#39;: 0, &#39;total_lines&#39;: 0, &#39;total_chars&#39;: 0}
    file_details = []
    
    for fname in coder.get_inchat_relative_files():
        try:
            path = Path(coder.abs_root_path(fname))
            if path.exists():
                content = path.read_text()
                lines = len(content.splitlines())
                chars = len(content)
                
                stats[&#39;total_files&#39;] += 1
                stats[&#39;total_lines&#39;] += lines
                stats[&#39;total_chars&#39;] += chars
                
                file_details.append({
                    &#39;name&#39;: fname,
                    &#39;size&#39;: path.stat().st_size,
                    &#39;lines&#39;: lines,
                    &#39;chars&#39;: chars
                })
        except Exception:
            continue
            
    return stats, file_details

def cmd_context_show(self, args):
    &quot;&quot;&quot;Save and display current chat context as HTML
    Usage: /showcontext
    
    Saves the current chat context including files, messages, and metadata 
    as a formatted HTML file and opens it in the default browser.
    Files are saved in .extn_aider/context/ with timestamps.
    &quot;&quot;&quot;
    timestamp = datetime.now().strftime(&#39;%Y%m%d_%H%M%S&#39;)
    
    # Create context directory
    context_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;temp&#39; /&#39;context&#39;
    context_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate content
    content = []
    
    # Header
    content.append(&#39;&lt;div class=&quot;header&quot;&gt;&#39;)
    content.append(f&#39;&lt;h1&gt;Aider Chat Context - {datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)}&lt;/h1&gt;&#39;)
    content.append(&#39;&lt;/div&gt;&#39;)
    
    # Metadata section
    content.append(&#39;&lt;div class=&quot;metadata section&quot;&gt;&#39;)
    
    # Model info
    content.append(&#39;&lt;div class=&quot;metadata-item&quot;&gt;&#39;)
    content.append(&#39;&lt;h3&gt;Model Information&lt;/h3&gt;&#39;)
    content.append(f&#39;&lt;p&gt;Main Model: {escape_html(self.coder.main_model.name)}&lt;/p&gt;&#39;)
    content.append(f&#39;&lt;p&gt;Edit Format: {escape_html(self.coder.edit_format)}&lt;/p&gt;&#39;)
    if self.coder.main_model.weak_model and self.coder.main_model.weak_model != self.coder.main_model:
        content.append(f&#39;&lt;p&gt;Weak Model: {escape_html(self.coder.main_model.weak_model.name)}&lt;/p&gt;&#39;)
    content.append(&#39;&lt;/div&gt;&#39;)
    
    # Files in chat
    content.append(&#39;&lt;div class=&quot;metadata-item&quot;&gt;&#39;)
    content.append(&#39;&lt;h3&gt;Files in Chat&lt;/h3&gt;&#39;)
    stats, file_details = get_file_stats(self.coder)
    content.append(&#39;&lt;div class=&quot;stats&quot;&gt;&#39;)
    content.append(f&#39;&lt;div&gt;Total Files: {stats[&quot;total_files&quot;]}&lt;/div&gt;&#39;)
    content.append(f&#39;&lt;div&gt;Total Lines: {stats[&quot;total_lines&quot;]:,}&lt;/div&gt;&#39;)
    content.append(f&#39;&lt;div&gt;Total Chars: {stats[&quot;total_chars&quot;]:,}&lt;/div&gt;&#39;)
    content.append(&#39;&lt;/div&gt;&#39;)
    content.append(&#39;&lt;ul class=&quot;file-list&quot;&gt;&#39;)
    for file in sorted(file_details, key=lambda x: x[&#39;name&#39;]):
        size_kb = file[&#39;size&#39;] / 1024
        content.append(
            f&#39;&lt;li&gt;{file[&quot;name&quot;]} ({size_kb:.1f}KB, {file[&quot;lines&quot;]:,} lines)&lt;/li&gt;&#39;
        )
    content.append(&#39;&lt;/ul&gt;&#39;)
    content.append(&#39;&lt;/div&gt;&#39;)
    
    # Git info if available
    if self.coder.repo:
        content.append(&#39;&lt;div class=&quot;metadata-item&quot;&gt;&#39;)
        content.append(&#39;&lt;h3&gt;Git Information&lt;/h3&gt;&#39;)
        try:
            repo = self.coder.repo.repo
            branch = repo.active_branch.name
            commit = repo.head.commit
            content.append(f&#39;&lt;p&gt;Branch: {escape_html(branch)}&lt;/p&gt;&#39;)
            content.append(f&#39;&lt;p&gt;Last Commit: {escape_html(commit.hexsha[:7])}&lt;/p&gt;&#39;)
            content.append(f&#39;&lt;p&gt;Author: {escape_html(str(commit.author))}&lt;/p&gt;&#39;)
            content.append(f&#39;&lt;p&gt;Date: {escape_html(str(commit.committed_datetime))}&lt;/p&gt;&#39;)
        except Exception as e:
            content.append(f&#39;&lt;p&gt;Error getting git info: {escape_html(str(e))}&lt;/p&gt;&#39;)
        content.append(&#39;&lt;/div&gt;&#39;)
    
    content.append(&#39;&lt;/div&gt;&#39;)  # End metadata section
    
    # Chat history
    content.append(&#39;&lt;div class=&quot;section&quot;&gt;&#39;)
    content.append(&#39;&lt;h2&gt;Chat History&lt;/h2&gt;&#39;)
    messages = (self.coder.done_messages + self.coder.cur_messages)
    content.append(format_messages(messages))
    content.append(&#39;&lt;/div&gt;&#39;)
    
    # Files content
    content.append(&#39;&lt;div class=&quot;section&quot;&gt;&#39;)
    content.append(&#39;&lt;h2&gt;File Contents&lt;/h2&gt;&#39;)
    for fname in sorted(self.coder.get_inchat_relative_files()):
        content.append(f&#39;&lt;h3&gt;{escape_html(fname)}&lt;/h3&gt;&#39;)
        try:
            path = Path(self.coder.abs_root_path(fname))
            file_content = path.read_text()
            content.append(&#39;&lt;div class=&quot;file-content&quot;&gt;&#39;)
            content.append(f&#39;&lt;pre&gt;{escape_html(file_content)}&lt;/pre&gt;&#39;)
            content.append(&#39;&lt;/div&gt;&#39;)
        except Exception as e:
            content.append(f&#39;&lt;p&gt;Error reading file: {escape_html(str(e))}&lt;/p&gt;&#39;)
    content.append(&#39;&lt;/div&gt;&#39;)
    
    # Generate full HTML
    html = HTML_TEMPLATE.format(
        timestamp=timestamp,
        content=&#39;\n&#39;.join(content)
    )
    
    # Save the file
    output_file_name = f&#39;context_{timestamp}_AiderContext.html&#39;
    output_file = context_dir / output_file_name
    output_file.write_text(html, encoding=&quot;utf-8&quot;)
    
    self.io.tool_output(f&quot;\nSaved context to {output_file}&quot;)
    
    # Open in browser
    try:
        webbrowser.open(output_file.as_uri())
        self.io.tool_output(&quot;Opened in default browser&quot;)
    except Exception as e:
        self.io.tool_error(f&quot;Error opening browser: {e}&quot;)
        self.io.tool_output(f&quot;You can manually open: {output_file}&quot;)

# Register commands
CommandsRegistry.register(&quot;context_show&quot;, cmd_context_show)</pre>
</div>
<h3>custom_aider/commands/customchat_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Custom chat command with keyword expansion support&quot;&quot;&quot;

import json
from pathlib import Path

from ..commands_registry import CommandsRegistry

KEYWORDS_FILE = &quot;.extn_aider.keywords.json&quot;

def load_keywords(io, root=&quot;.&quot;):
    &quot;&quot;&quot;Load keywords from the keywords JSON file&quot;&quot;&quot;
    try:
        keywords_path = Path(root) / &#39;.extn_aider&#39; / KEYWORDS_FILE
        if not keywords_path.exists():
            io.tool_error(f&quot;Keywords file not found: {KEYWORDS_FILE}&quot;)
            return {}
            
        with open(keywords_path) as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        io.tool_error(f&quot;Invalid JSON in {KEYWORDS_FILE}: {e}&quot;)
        return {}
    except Exception as e:
        io.tool_error(f&quot;Error reading {KEYWORDS_FILE}: {e}&quot;)
        return {}

def expand_keywords(text, keywords, io):
    &quot;&quot;&quot;Replace @text-keyword patterns with their expansions&quot;&quot;&quot;
    import re
    
    # Find all @text- keywords
    pattern = r&#39;@text-(\w+)&#39;
    matches = re.finditer(pattern, text)
    
    # Track replacements and errors
    replacements = []
    missing_keywords = set()
    
    # Collect all replacements first
    for match in matches:
        keyword = match.group(1)
        if keyword in keywords:
            replacements.append((match.span(), keywords[keyword]))
        else:
            missing_keywords.add(keyword)
            
    # Report missing keywords
    if missing_keywords:
        io.tool_error(&quot;Unknown keywords:&quot;)
        for kw in sorted(missing_keywords):
            io.tool_error(f&quot;  @text-{kw}&quot;)
        return None
        
    # Apply replacements in reverse order to not mess up positions
    expanded = text
    for (start, end), replacement in sorted(replacements, reverse=True):
        expanded = expanded[:start] + replacement + expanded[end:]
        
    if replacements:
        io.tool_output(&quot;\nExpanded message:&quot;)
        io.tool_output(expanded)
        io.tool_output(&quot;\nPress Enter to send or Ctrl-C to cancel...&quot;)
        try:
            input()
        except KeyboardInterrupt:
            return None
            
    return expanded

def cmd_customchat(self, args):
    &quot;&quot;&quot;Enhanced chat with keyword substitution support
    Usage: /customchat &lt;message&gt;
    
    Your message can contain @text-keyword references that will be expanded
    based on definitions in .extn_aider.keywords.json.
    
    Example keywords file:
    {
        &quot;api&quot;: &quot;REST API with JSON responses&quot;,
        &quot;tests&quot;: &quot;Unit tests using pytest with mocking&quot;
    }
    
    Example usage:
    /customchat Create @text-tests for the login function
    &quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please provide a message&quot;)
        return
        
    # Load keywords
    keywords = load_keywords(self.io, root=self.coder.root)
    if not keywords:
        return
        
    # Expand keywords in message
    expanded = expand_keywords(args, keywords, self.io)
    if not expanded:
        return
        
    # Process based on current edit format
    edit_format = self.coder.edit_format
    
    if edit_format == &quot;ask&quot;:
        return self.cmd_ask(expanded)
    elif edit_format == &quot;architect&quot;:
        return self.cmd_architect(expanded)
    else:
        return self.cmd_code(expanded)

# Add completion support
def completions_customchat(self):
    &quot;&quot;&quot;Provide completions for customchat command&quot;&quot;&quot;
    # Get document text before cursor
    # The completion engine automatically passes Document and CompleteEvent objects
    # We only care about text before cursor to find potential @text- pattern
    
    # Load keywords 
    keywords = load_keywords(self.io, root=self.coder.root) 
    if not keywords:
        return []

    # Filter and format completions
    completions = []
    for keyword in keywords:
        completions.append(&#39;@text-&#39; + keyword)

    return sorted(completions)

# Register command with completions
CommandsRegistry.register(&quot;customchat&quot;, cmd_customchat, completions_customchat)</pre>
</div>
<h3>custom_aider/commands/docrag_commands.py</h3>
<div class="file-content">
<pre>import os
import json
import shutil
from pathlib import Path
from datetime import datetime
import warnings

from llama_index.core import (
    Document,
    StorageContext,
    VectorStoreIndex,
    load_index_from_storage,
)
from llama_index.core.node_parser import MarkdownNodeParser
from llama_index.embeddings.huggingface import HuggingFaceEmbedding
from ..commands_registry import CommandsRegistry

# Suppress FutureWarning from tree-sitter
warnings.simplefilter(&quot;ignore&quot;, category=FutureWarning)

# Constants
RAG_CACHE_DIR = Path.home() / &quot;.extn_aider&quot; / &quot;rags&quot;

class RAGManager:
    &quot;&quot;&quot;Manages RAG operations and persistence using aider&#39;s help infrastructure&quot;&quot;&quot;
    
    def __init__(self):
        &quot;&quot;&quot;Initialize RAG manager with HuggingFace embeddings&quot;&quot;&quot;
        os.environ[&quot;TOKENIZERS_PARALLELISM&quot;] = &quot;true&quot;
        self.embed_model = HuggingFaceEmbedding(
            model_name=&quot;BAAI/bge-small-en-v1.5&quot;
        )
        self.parser = MarkdownNodeParser()
        self.cache_dir = RAG_CACHE_DIR
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.metadata_file = self.cache_dir / &quot;metadata.json&quot;
        self.metadata = self._load_metadata()

    def _load_metadata(self):
        &quot;&quot;&quot;Load RAG metadata from disk&quot;&quot;&quot;
        if self.metadata_file.exists():
            try:
                return json.loads(self.metadata_file.read_text())
            except json.JSONDecodeError:
                return {}
        return {}

    def _save_metadata(self):
        &quot;&quot;&quot;Save RAG metadata to disk&quot;&quot;&quot;
        self.metadata_file.write_text(json.dumps(self.metadata, indent=2))

    def create_rag(self, nickname: str, doc_path: str) -&gt; str:
        &quot;&quot;&quot;Create a new RAG from document&quot;&quot;&quot;
        try:
            doc_path = Path(doc_path).resolve()
            if not doc_path.exists():
                return f&quot;Error: Document not found at {doc_path}&quot;

            # Create RAG directory
            rag_dir = self.cache_dir / nickname
            if rag_dir.exists():
                return f&quot;Error: RAG &#39;{nickname}&#39; already exists&quot;

            # Read document content
            try:
                content = doc_path.read_text(encoding=&#39;utf-8&#39;)
            except UnicodeDecodeError:
                return f&quot;Error: Could not read {doc_path}. File must be text/markdown&quot;

            # Create document
            doc = Document(
                text=content,
                metadata=dict(
                    filename=doc_path.name,
                    extension=doc_path.suffix,
                )
            )

            # Parse nodes
            nodes = self.parser.get_nodes_from_documents([doc])

            # Create and save index
            index = VectorStoreIndex(nodes, embed_model=self.embed_model)
            
            # Save index
            rag_dir.mkdir(parents=True, exist_ok=True)
            index.storage_context.persist(persist_dir=str(rag_dir))

            # Update metadata
            self.metadata[nickname] = {
                &quot;path&quot;: str(doc_path),
                &quot;created&quot;: datetime.now().isoformat(),
                &quot;num_nodes&quot;: len(nodes)
            }
            self._save_metadata()

            return f&quot;Successfully created RAG &#39;{nickname}&#39; with {len(nodes)} chunks&quot;

        except Exception as e:
            # Clean up if failed
            if rag_dir.exists():
                shutil.rmtree(rag_dir)
            return f&quot;Error creating RAG: {str(e)}&quot;

    def query_rag(self, nickname: str, query: str, k: int = 3, coder=None) -&gt; str:
        &quot;&quot;&quot;Query an existing RAG&quot;&quot;&quot;
        try:
            if nickname not in self.metadata:
                return f&quot;Error: RAG &#39;{nickname}&#39; not found&quot;

            rag_dir = self.cache_dir / nickname
            if not rag_dir.exists():
                return f&quot;Error: RAG directory for &#39;{nickname}&#39; not found&quot;

            # Load index
            try:
                storage_context = StorageContext.from_defaults(
                    persist_dir=str(rag_dir)
                )
                index = load_index_from_storage(
                    storage_context,
                    embed_model=self.embed_model
                )
            except Exception as e:
                return f&quot;Error loading RAG: {str(e)}&quot;

            # Create retriever
            retriever = index.as_retriever(similarity_top_k=k)

            # Get results
            nodes = retriever.retrieve(query)

            # Format results
            output = [f&quot;\nSearch results from RAG &#39;{nickname}&#39;:\n&quot;]
            
            for i, node in enumerate(nodes, 1):
                score = node.score or 0
                relevance = max(0, min(1, score))  # Clamp between 0 and 1
                
                output.append(f&quot;\n--- Result {i} (Relevance: {relevance:.2%}) ---&quot;)
                output.append(node.text.strip())
                if node.metadata:
                    source = node.metadata.get(&#39;filename&#39;, &#39;unknown&#39;)
                    output.append(f&quot;\nSource: {source}&quot;)

            output.append(&quot;\n--- End of results ---&quot;)
            outputstr = &quot;\n&quot;.join(output)
            return True, outputstr

        except Exception as e:
            return False, f&quot;Error querying RAG: {str(e)}&quot;

    def get_rag_list(self) -&gt; str:
        &quot;&quot;&quot;Get formatted list of available RAGs&quot;&quot;&quot;
        if not self.metadata:
            return &quot;No RAGs available&quot;

        output = [&quot;Available RAGs:&quot;]
        for nickname, info in self.metadata.items():
            created = datetime.fromisoformat(info[&#39;created&#39;]).strftime(&#39;%Y-%m-%d %H:%M&#39;)
            num_nodes = info.get(&#39;num_nodes&#39;, &#39;unknown&#39;)
            path = info.get(&#39;path&#39;, &#39;unknown&#39;)
            output.append(f&quot;\n{nickname}:&quot;)
            output.append(f&quot;  Source: {path}&quot;)
            output.append(f&quot;  Chunks: {num_nodes}&quot;)
            output.append(f&quot;  Created: {created}&quot;)

        return &quot;\n&quot;.join(output)

    def delete_rag(self, nickname: str) -&gt; str:
        &quot;&quot;&quot;Delete a RAG&quot;&quot;&quot;
        if nickname not in self.metadata:
            return f&quot;Error: RAG &#39;{nickname}&#39; not found&quot;

        rag_dir = self.cache_dir / nickname
        if rag_dir.exists():
            try:
                shutil.rmtree(rag_dir)
            except Exception as e:
                return f&quot;Error deleting RAG directory: {str(e)}&quot;

        del self.metadata[nickname]
        self._save_metadata()

        return f&quot;Successfully deleted RAG &#39;{nickname}&#39;&quot;

# Initialize RAG manager
rag_manager = RAGManager()

def cmd_createragfromdoc(self, args):
    &quot;&quot;&quot;Create a RAG from a text/markdown document
    Usage: /createragfromdoc &lt;nickname&gt; &lt;document_path&gt;
    
    Creates a RAG (Retrieval Augmented Generation) index from a text/markdown document.
    The document must be a text file - PDFs and other binary formats are not supported.
    The RAG can later be queried using /queryragfromdoc.
    
    Example:
        /createragfromdoc docs_rag /path/to/document.md
    &quot;&quot;&quot;
    parts = args.strip().split(maxsplit=1)
    if len(parts) != 2:
        self.io.tool_error(&quot;Usage: /createragfromdoc &lt;nickname&gt; &lt;document_path&gt;&quot;)
        return
        
    nickname, doc_path = parts
    
    # Validate nickname
    if not nickname.isalnum():
        self.io.tool_error(&quot;Nickname must be alphanumeric&quot;)
        return
        
    # Create RAG
    self.io.tool_output(f&quot;Creating RAG &#39;{nickname}&#39;...&quot;)
    result = rag_manager.create_rag(nickname, doc_path)
    self.io.tool_output(result)

def cmd_queryragfromdoc(self, args):
    &quot;&quot;&quot;Query an existing RAG
    Usage: /queryragfromdoc &lt;nickname&gt; &lt;query&gt;
    
    Searches the specified RAG for content relevant to your query
    and returns the most similar passages.
    
    Example:
        /queryragfromdoc docs_rag &quot;How do I use the git commands?&quot;
    &quot;&quot;&quot;
    parts = args.strip().split(maxsplit=1)
    if len(parts) != 2:
        self.io.tool_error(&quot;Usage: /queryragfromdoc &lt;nickname&gt; &lt;query&gt;&quot;)
        return
        
    nickname, query = parts
    
    # Query RAG
    self.io.tool_output(f&quot;Querying RAG &#39;{nickname}&#39;...&quot;)
    success,result = rag_manager.query_rag(nickname, query, 3)
    if success:
        result = result.strip()
        result = &quot;For the query:\n\n&quot; + query + &quot;\n\n&quot; + result
        self.io.tool_output(result)
        
        self.coder.cur_messages += [
            dict(role=&quot;user&quot;, content=result),
            dict(role=&quot;assistant&quot;, content=&quot;Ok.&quot;),
        ]
    else:
        self.io.tool_error(result)

def cmd_listrag(self, args=&quot;&quot;):
    &quot;&quot;&quot;List all available RAGs
    Usage: /listrag
    
    Shows information about all available RAGs including
    their source documents, number of chunks, and creation dates.
    &quot;&quot;&quot;
    self.io.tool_output(rag_manager.get_rag_list())

def cmd_deleterag(self, args):
    &quot;&quot;&quot;Delete a RAG
    Usage: /deleterag &lt;nickname&gt;
    
    Permanently deletes the specified RAG and frees up disk space.
    &quot;&quot;&quot;
    nickname = args.strip()
    if not nickname:
        self.io.tool_error(&quot;Usage: /deleterag &lt;nickname&gt;&quot;)
        return
        
    result = rag_manager.delete_rag(nickname)
    self.io.tool_output(result)

def completions_createragfromdoc(self):
    &quot;&quot;&quot;No completions for createragfromdoc - nickname should be new&quot;&quot;&quot;
    return [&quot;ragnickname&quot;, &quot;documentpath&quot;]

def completions_queryragfromdoc(self):
    &quot;&quot;&quot;Provide completions for queryragfromdoc command - existing nicknames&quot;&quot;&quot;
    return list(rag_manager.metadata.keys())

def completions_deleterag(self):
    &quot;&quot;&quot;Provide completions for deleterag command - existing nicknames&quot;&quot;&quot;
    return list(rag_manager.metadata.keys())

# Register commands
CommandsRegistry.register(&quot;createragfromdoc&quot;, cmd_createragfromdoc, completions_createragfromdoc)
CommandsRegistry.register(&quot;queryragfromdoc&quot;, cmd_queryragfromdoc, completions_queryragfromdoc)
CommandsRegistry.register(&quot;listrag&quot;, cmd_listrag)
CommandsRegistry.register(&quot;deleterag&quot;, cmd_deleterag, completions_deleterag)</pre>
</div>
<h3>custom_aider/commands/editor_tkinter_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for launching the enhanced tkinter editor&quot;&quot;&quot;

import os
import subprocess
import sys
from pathlib import Path
import pkg_resources

from ..commands_registry import CommandsRegistry

def ensure_dependencies():
    &quot;&quot;&quot;Ensure required packages are installed&quot;&quot;&quot;
    required = {&#39;pygments&#39;}
    installed = {pkg.key for pkg in pkg_resources.working_set}
    missing = required - installed
    
    if missing:
        # Install missing packages
        python = sys.executable
        subprocess.check_call([
            python, &#39;-m&#39;, &#39;pip&#39;, &#39;install&#39;, *missing,
            &#39;--quiet&#39;, &#39;--disable-pip-version-check&#39;
        ])
        return True
    return False

def cmd_editor_tkinter(self, initial_content=&quot;&quot;):
    &quot;&quot;&quot;Open the enhanced tkinter editor for writing prompts
    Usage: /editor_tkinter [initial_text]
    
    Opens a graphical editor window with:
    - Syntax highlighting for multiple formats
    - Keyword suggestions (type @keyword)
    - Status bar with document statistics
    - Control+S to save and close
    - Escape to cancel
    
    The tkinter editor uses keywords from .extn_aider.keywords.json for suggestions.
    &quot;&quot;&quot;
    # Ensure dependencies are installed
    try:
        if ensure_dependencies():
            self.io.tool_output(&quot;Installing required packages...&quot;)
    except Exception as e:
        self.io.tool_error(f&quot;Error installing dependencies: {e}&quot;)
        return None
        
    # Get package directory
    package_dir = Path(__file__).parent.parent
    
    # Import the editor directly
    try:
        from ..gui.editors.editor_tkinter.editor_tkinter import SimpleEditor
        
        # Create and run editor
        editor = SimpleEditor(initial_content)
        result = editor.run()
        
        if result is not None:
            return result
            
    except Exception as e:
        self.io.tool_error(f&quot;Error running tkinter editor: {e}&quot;)
        return None

# Register the editor command
CommandsRegistry.register(&quot;editor_tkinter&quot;, cmd_editor_tkinter)</pre>
</div>
<h3>custom_aider/commands/existing_commands.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;
Startup script that adds wrapped versions of existing Aider commands.
Each wrapper starts with &#39;z&#39; and adds additional functionality.
&quot;&quot;&quot;
import time
from pathlib import Path
import re
from ..commands_registry import CommandsRegistry

#convert url to a valid filename
def converturltofilename(url):
    # Replace all non-alphanumeric characters with underscores
    filename = re.sub(r&#39;\W+&#39;, &#39;_&#39;, url)
    return filename

# Web command wrapper - adds timing and retries
def cmd_zweb(self, args):
    &quot;&quot;&quot;Enhanced /web command with timing and retry support&quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please provide a URL&quot;)
        return
        
    start_time = time.time()
    retries = 2
    
    while retries &gt; 0:
        try:
            self.io.tool_output(f&quot;Fetching {args} (retries left: {retries})...&quot;)
            content = self.cmd_web(args, return_content=True)
            self.io.tool_output(&quot;... added to chat.&quot;)

            self.coder.cur_messages += [
                dict(role=&quot;user&quot;, content=content),
                dict(role=&quot;assistant&quot;, content=&quot;Ok.&quot;),
            ]

            if content:
                elapsed = time.time() - start_time
                self.io.tool_output(f&quot;Fetched in {elapsed:.2f} seconds&quot;)
                word_count = len(content.split())
                self.io.tool_output(f&quot;Word count: {word_count:,}&quot;)
                #save content to a file - .extn_aider/temp/web
                web_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;temp&#39; / &#39;web&#39;
                web_dir.mkdir(parents=True, exist_ok=True)
                saved_file_name = f&quot;{time.strftime(&#39;%Y%m%d_%H%M%S&#39;)}__{converturltofilename(args)}.txt&quot;
                web_file = web_dir / saved_file_name
                web_file.write_text(content, encoding=&#39;utf-8&#39;)
                self.io.tool_output(f&quot;Content saved to .extn_aider/temp/web/{saved_file_name}&quot;)
                #self.io.tool_output(&quot;\n\n&quot;+content)
                retries = 0
                return
                #return content
            else:
                self.io.tool_error(&quot;No content found&quot;)
                retries -= 1
        except Exception as e:
            self.io.tool_error(f&quot;Error: {e}&quot;)
            retries -= 1
            if retries &gt; 0:
                time.sleep(2)  # Wait before retry
                
    self.io.tool_error(&quot;Failed to fetch content after multiple retries&quot;)



# Add command wrapper - adds file validation and git status
def cmd_zadd(self, args):
    &quot;&quot;&quot;Enhanced /add command with validation and git status&quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please specify files to add&quot;)
        return
        
    # Show git status before adding
    if self.coder.repo:
        try:
            status = self.coder.repo.repo.git.status(short=True)
            if status:
                self.io.tool_output(&quot;Git status before adding files:&quot;)
                self.io.tool_output(status)
        except Exception as e:
            self.io.tool_error(f&quot;Git error: {e}&quot;)
            
    # Track sizes of added files
    initial_sizes = {}
    for fname in self.coder.get_inchat_relative_files():
        try:
            size = Path(self.coder.abs_root_path(fname)).stat().st_size
            initial_sizes[fname] = size
        except Exception:
            pass
            
    # Call original add command
    self.cmd_add(args)
    
    # Show what changed
    self.io.tool_output(&quot;\nSummary of changes:&quot;)
    for fname in self.coder.get_inchat_relative_files():
        try:
            size = Path(self.coder.abs_root_path(fname)).stat().st_size
            if fname in initial_sizes:
                if size != initial_sizes[fname]:
                    self.io.tool_output(f&quot;Modified: {fname} ({size:,} bytes)&quot;)
            else:
                self.io.tool_output(f&quot;Added: {fname} ({size:,} bytes)&quot;)
        except Exception:
            pass
            

# Drop command wrapper - adds confirmation and backup
def cmd_zdrop(self, args):
    &quot;&quot;&quot;Enhanced /drop command with confirmation and backup&quot;&quot;&quot;
    if not args.strip():
        if not self.io.confirm_ask(&quot;Drop all files from chat?&quot;, default=&quot;n&quot;):
            return
            
    files_to_drop = []
    if args.strip():
        files_to_drop = args.strip().split()
    else:
        files_to_drop = self.coder.get_inchat_relative_files()
        
    # Create backups
    backup_dir = Path.home() / &#39;.extn_aider&#39; / &#39;temp&#39; / &#39;backups&#39;
    backup_dir.mkdir(parents=True, exist_ok=True)
    
    timestamp = time.strftime(&#39;%Y%m%d_%H%M%S&#39;)
    backed_up = []
    
    for fname in files_to_drop:
        try:
            full_path = self.coder.abs_root_path(fname)
            if Path(full_path).exists():
                backup_path = backup_dir / f&quot;{fname.replace(&#39;/&#39;, &#39;_&#39;)}_{timestamp}&quot;
                backup_path.write_text(Path(full_path).read_text())
                backed_up.append(fname)
        except Exception as e:
            self.io.tool_error(f&quot;Backup error for {fname}: {e}&quot;)
            
    if backed_up:
        self.io.tool_output(f&quot;Backed up {len(backed_up)} files to {backup_dir}&quot;)
        
    # Call original drop command
    self.cmd_drop(args)
    

# Commit command wrapper - adds file stats and commit message enhancement
def cmd_zcommit(self, args):
    &quot;&quot;&quot;Enhanced /commit command with stats and message enhancement&quot;&quot;&quot;
    if not self.coder.repo:
        self.io.tool_error(&quot;No git repository found&quot;)
        return
        
    repo = self.coder.repo.repo
    
    # Get stats before commit
    stats = {}
    for fname in repo.git.diff(None, name_only=True).split():
        try:
            with open(fname) as f:
                lines = f.readlines()
                stats[fname] = {
                    &#39;lines&#39;: len(lines),
                    &#39;words&#39;: sum(len(line.split()) for line in lines)
                }
        except Exception:
            pass
            
    # Show what&#39;s being committed
    if stats:
        self.io.tool_output(&quot;Files to be committed:&quot;)
        for fname, file_stats in stats.items():
            self.io.tool_output(
                f&quot;  {fname}: {file_stats[&#39;lines&#39;]:,} lines, &quot;
                f&quot;{file_stats[&#39;words&#39;]:,} words&quot;
            )
            
    # Add stats to commit message if no message provided
    if not args:
        stats_msg = &quot;\n\nFile statistics:\n&quot;
        for fname, file_stats in stats.items():
            stats_msg += f&quot;- {fname}: {file_stats[&#39;lines&#39;]} lines modified\n&quot;
        args = stats_msg
        
    # Call original commit command
    result = self.cmd_commit(args)
    
    # Show commit details
    if result:
        commit = repo.head.commit
        self.io.tool_output(f&quot;\nCommit: {commit.hexsha[:7]}&quot;)
        self.io.tool_output(f&quot;Author: {commit.author}&quot;)
        self.io.tool_output(f&quot;Date: {commit.committed_datetime}&quot;)
        
    return result
    

# Model command wrapper - adds model comparison
def cmd_zmodel(self, args):
    &quot;&quot;&quot;Enhanced /model command with model comparison&quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please specify a model&quot;)
        return
        
    # Get current model info
    current_model = self.coder.main_model
    current_info = current_model.info
    
    # Call original model command
    self.cmd_model(args)
    
    # Get new model info
    new_model = self.coder.main_model
    new_info = new_model.info
    
    # Compare and show differences
    self.io.tool_output(&quot;\nModel comparison:&quot;)
    self.io.tool_output(f&quot;Previous: {current_model.name}&quot;)
    self.io.tool_output(f&quot;New: {new_model.name}&quot;)
    
    if current_info and new_info:
        comparisons = [
            (&#39;Input tokens&#39;, &#39;max_input_tokens&#39;),
            (&#39;Output tokens&#39;, &#39;max_output_tokens&#39;),
            (&#39;Input cost&#39;, &#39;input_cost_per_token&#39;),
            (&#39;Output cost&#39;, &#39;output_cost_per_token&#39;)
        ]
        
        for label, key in comparisons:
            old_val = current_info.get(key, &#39;N/A&#39;)
            new_val = new_info.get(key, &#39;N/A&#39;)
            if old_val != new_val:
                self.io.tool_output(f&quot;{label}: {old_val} → {new_val}&quot;)
                

# Clear command wrapper - adds backup of chat history
def cmd_zclear(self, args):
    &quot;&quot;&quot;Enhanced /clear command with history backup&quot;&quot;&quot;
    # Backup current chat history
    if self.coder.done_messages:
        backup_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;temp&#39; / &#39;history_backups&#39;
        backup_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = time.strftime(&#39;%Y%m%d_%H%M%S&#39;)
        backup_file = backup_dir / f&quot;chat_history_{timestamp}.md&quot;
        
        try:
            with open(backup_file, &#39;w&#39;) as f:
                for msg in self.coder.done_messages:
                    f.write(f&quot;## {msg[&#39;role&#39;].upper()}\n&quot;)
                    f.write(msg[&#39;content&#39;])
                    f.write(&quot;\n\n&quot;)
                    
            self.io.tool_output(f&quot;Chat history backed up to {backup_file}&quot;)
        except Exception as e:
            self.io.tool_error(f&quot;Backup error: {e}&quot;)
            
    # Call original clear command
    self.cmd_clear(args)
    
# Voice command wrapper - adds transcription confidence and retry
def cmd_zvoice(self, args):
    &quot;&quot;&quot;Enhanced /voice command with confidence check and retry&quot;&quot;&quot;
    max_retries = 3
    min_confidence = 0.8  # minimum confidence threshold
    
    for attempt in range(max_retries):
        self.io.tool_output(f&quot;Recording attempt {attempt + 1}/{max_retries}...&quot;)
        
        text = self.cmd_voice(args)
        
        if not text:
            self.io.tool_error(&quot;No transcription received&quot;)
            continue
            
        # Here we could check transcription confidence if the API provided it
        # For now, we&#39;ll ask the user
        if self.io.confirm_ask(&quot;Was the transcription accurate? (Y/n)&quot;, default=&quot;y&quot;):
            return text
            
        if attempt &lt; max_retries - 1:
            self.io.tool_output(&quot;Let&#39;s try again...&quot;)
            
    self.io.tool_error(&quot;Max retries reached. Using last transcription.&quot;)
    return text
    
# Register commands
CommandsRegistry.register(&quot;zadd&quot;, cmd_zadd)
CommandsRegistry.register(&quot;zdrop&quot;, cmd_zdrop)
CommandsRegistry.register(&quot;zcommit&quot;, cmd_zcommit)
CommandsRegistry.register(&quot;zclear&quot;, cmd_zclear)
CommandsRegistry.register(&quot;zmodel&quot;, cmd_zmodel)
CommandsRegistry.register(&quot;zvoice&quot;, cmd_zvoice)
CommandsRegistry.register(&quot;zweb&quot;, cmd_zweb)</pre>
</div>
<h3>custom_aider/commands/explain_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for interactive code explanation with HTML output&quot;&quot;&quot;
import os
import re
import ast
import webbrowser
from pathlib import Path
from datetime import datetime
from jinja2 import Template

from ..commands_registry import CommandsRegistry

# Get template directory
TEMPLATE_DIR = Path(__file__).parent.parent / &#39;gui&#39; / &#39;templates&#39; / &#39;cmd_explain_tmpl&#39;

class CodeAnalyzer:
    &quot;&quot;&quot;Analyzes Python code using AST&quot;&quot;&quot;
    
    def __init__(self, code_text):
        self.code_text = code_text
        self.tree = ast.parse(code_text)
        
    def find_target(self, target_name):
        &quot;&quot;&quot;Find a specific function or class definition&quot;&quot;&quot;
        for node in ast.walk(self.tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                if node.name == target_name:
                    return self.analyze_node(node)
        return None
        
    def analyze_node(self, node):
        &quot;&quot;&quot;Analyze a specific AST node&quot;&quot;&quot;
        analysis = {
            &#39;name&#39;: node.name,
            &#39;type&#39;: self._get_node_type(node),
            &#39;docstring&#39;: ast.get_docstring(node) or &#39;&#39;,
            &#39;source&#39;: self._get_node_source(node),
            &#39;lineno&#39;: node.lineno
        }
        
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            analysis.update(self._analyze_function(node))
        elif isinstance(node, ast.ClassDef):
            analysis.update(self._analyze_class(node))
            
        return analysis
        
    def _get_node_type(self, node):
        if isinstance(node, ast.AsyncFunctionDef):
            return &#39;async function&#39;
        elif isinstance(node, ast.FunctionDef):
            return &#39;function&#39;
        elif isinstance(node, ast.ClassDef):
            return &#39;class&#39;
        return &#39;unknown&#39;
        
    def _get_node_source(self, node):
        &quot;&quot;&quot;Get source code for a node&quot;&quot;&quot;
        return ast.unparse(node)
        
    def _analyze_function(self, node):
        &quot;&quot;&quot;Analyze a function definition&quot;&quot;&quot;
        args = []
        defaults = []
        
        for arg in node.args.args:
            args.append(arg.arg)
            
        if node.args.defaults:
            defaults = [ast.unparse(default) for default in node.args.defaults]
            
        return {
            &#39;args&#39;: args,
            &#39;defaults&#39;: defaults,
            &#39;body_info&#39;: self._analyze_body(node)
        }
        
    def _analyze_class(self, node):
        &quot;&quot;&quot;Analyze a class definition&quot;&quot;&quot;
        methods = []
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                methods.append(self.analyze_node(item))
                
        return {
            &#39;methods&#39;: methods,
            &#39;bases&#39;: [ast.unparse(base) for base in node.bases],
            &#39;body_info&#39;: self._analyze_body(node)
        }
        
    def _analyze_body(self, node):
        &quot;&quot;&quot;Analyze function/class body&quot;&quot;&quot;
        info = {
            &#39;has_loops&#39;: False,
            &#39;has_conditionals&#39;: False,
            &#39;calls&#39;: [],
            &#39;line_count&#39;: len(node.body)
        }
        
        for item in ast.walk(node):
            if isinstance(item, (ast.For, ast.While)):
                info[&#39;has_loops&#39;] = True
            elif isinstance(item, ast.If):
                info[&#39;has_conditionals&#39;] = True
            elif isinstance(item, ast.Call) and hasattr(item.func, &#39;id&#39;):
                info[&#39;calls&#39;].append(item.func.id)
                
        return info

class HTMLExplanationGenerator:
    &quot;&quot;&quot;Generates HTML explanation for code analysis&quot;&quot;&quot;
    
    @staticmethod
    def generate_control_flow(analysis):
        &quot;&quot;&quot;Generate Mermaid diagram showing control flow&quot;&quot;&quot;
        mermaid = [&quot;graph TD&quot;]
        
        if analysis[&#39;type&#39;] in (&#39;function&#39;, &#39;async function&#39;):
            # Function flow
            mermaid.append(f&quot;    Start[Start] --&gt; Args[Process Arguments]&quot;)
            
            if analysis[&#39;body_info&#39;][&#39;has_conditionals&#39;]:
                mermaid.append(&quot;    Args --&gt; Conditions{Conditions}&quot;)
                mermaid.append(&quot;    Conditions --&gt;|True| Process[Process]&quot;)
                mermaid.append(&quot;    Conditions --&gt;|False| Alt[Alternative]&quot;)
                mermaid.append(&quot;    Process --&gt; End[Return]&quot;)
                mermaid.append(&quot;    Alt --&gt; End&quot;)
            else:
                mermaid.append(&quot;    Args --&gt; Process[Process]&quot;)
                mermaid.append(&quot;    Process --&gt; End[Return]&quot;)
                
        elif analysis[&#39;type&#39;] == &#39;class&#39;:
            # Class structure
            mermaid.append(f&quot;    C[{analysis[&#39;name&#39;]}]&quot;)
            for method in analysis.get(&#39;methods&#39;, []):
                mermaid.append(f&quot;    C --&gt; {method[&#39;name&#39;]}[{method[&#39;name&#39;]}()]&quot;)
                
        return &quot;\n&quot;.join(mermaid)

    @staticmethod
    def generate_html(analysis, level=&#39;basic&#39;):
        &quot;&quot;&quot;Generate complete HTML document&quot;&quot;&quot;
        # Load template files
        with open(TEMPLATE_DIR / &#39;base_template.html&#39;) as f:
            template = Template(f.read())
            
        with open(TEMPLATE_DIR / &#39;style.css&#39;) as f:
            styles = f.read()
            
        with open(TEMPLATE_DIR / &#39;script.js&#39;) as f:
            scripts = f.read()
        
        # Prepare template context
        context = {
            &#39;name&#39;: analysis[&#39;name&#39;],
            &#39;type&#39;: analysis[&#39;type&#39;],
            &#39;docstring&#39;: analysis[&#39;docstring&#39;],
            &#39;source&#39;: analysis[&#39;source&#39;],
            &#39;lineno&#39;: analysis[&#39;lineno&#39;],
            &#39;styles&#39;: styles,
            &#39;scripts&#39;: scripts,
            &#39;flow_diagram&#39;: HTMLExplanationGenerator.generate_control_flow(analysis),
            &#39;line_count&#39;: analysis[&#39;body_info&#39;][&#39;line_count&#39;],
            &#39;has_loops&#39;: analysis[&#39;body_info&#39;][&#39;has_loops&#39;],
            &#39;has_conditionals&#39;: analysis[&#39;body_info&#39;][&#39;has_conditionals&#39;],
            &#39;calls&#39;: analysis[&#39;body_info&#39;].get(&#39;calls&#39;, [])
        }
        
        # Add function-specific context
        if analysis[&#39;type&#39;] in (&#39;function&#39;, &#39;async function&#39;):
            args = analysis.get(&#39;args&#39;, [])
            defaults = analysis.get(&#39;defaults&#39;, [])
            
            # Add default values to args
            sig_parts = []
            default_offset = len(args) - len(defaults)
            for i, arg in enumerate(args):
                if i &gt;= default_offset and defaults:
                    sig_parts.append(f&quot;{arg}={defaults[i - default_offset]}&quot;)
                else:
                    sig_parts.append(arg)
                    
            context[&#39;signature&#39;] = f&quot;def {analysis[&#39;name&#39;]}({&#39;, &#39;.join(sig_parts)}):&quot;
            context[&#39;args&#39;] = args
            
        # Generate HTML using template
        return template.render(**context)

def cmd_explain(self, args):
    &quot;&quot;&quot;Interactive code explanation
    Usage: /explain &lt;function/class&gt; [--level basic/deep/eli5]
    
    Creates an interactive HTML view that lets you:
    - Click to expand/collapse explanation sections
    - Toggle between abstraction levels
    - See animated control flow diagrams
    - Get real examples from the codebase
    &quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please specify what to explain&quot;)
        return
        
    # Parse arguments
    parts = args.strip().split()
    target = parts[0]
    level = &quot;basic&quot;  # default level
    
    if len(parts) &gt; 1 and parts[1].startswith(&#39;--level=&#39;):
        level = parts[1].split(&#39;=&#39;)[1]
        if level not in (&#39;basic&#39;, &#39;deep&#39;, &#39;eli5&#39;):
            self.io.tool_error(&quot;Invalid level. Use: basic, deep, or eli5&quot;)
            return
            
    # Look for the target in files
    found = False
    for fname in self.coder.get_inchat_relative_files():
        try:
            if not fname.endswith(&#39;.py&#39;):
                continue
                
            path = Path(self.coder.abs_root_path(fname))
            content = path.read_text()
            
            analyzer = CodeAnalyzer(content)
            analysis = analyzer.find_target(target)
            
            if analysis:
                found = True
                self.io.tool_output(f&quot;\nAnalyzing {target} from {fname}...&quot;)
                
                # Generate HTML
                html = HTMLExplanationGenerator.generate_html(analysis, level)
                
                # Save HTML file
                output_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;temp&#39; / &#39;explain&#39;
                output_dir.mkdir(parents=True, exist_ok=True)
                
                timestamp = datetime.now().strftime(&#39;%Y%m%d_%H%M%S&#39;)
                output_file = output_dir / f&quot;explanation_{target}_{timestamp}.html&quot;
                
                output_file.write_text(html, encoding=&#39;utf-8&#39;)
                self.io.tool_output(f&quot;\nSaved explanation to {output_file}&quot;)
                
                # Open in browser
                try:
                    webbrowser.open(output_file.as_uri())
                    self.io.tool_output(&quot;Opened in default browser&quot;)
                except Exception as e:
                    self.io.tool_error(f&quot;Error opening browser: {e}&quot;)
                    self.io.tool_output(f&quot;You can manually open: {output_file}&quot;)
                break
                
        except Exception as e:
            self.io.tool_error(f&quot;Error processing {fname}: {e}&quot;)
            continue
            
    if not found:
        self.io.tool_error(f&quot;Could not find {target} in any Python files&quot;)

def completions_explain(self):
    &quot;&quot;&quot;Provide completions for explain command&quot;&quot;&quot;
    completions = []
    
    # Scan files for function and class definitions
    for fname in self.coder.get_inchat_relative_files():
        try:
            if not fname.endswith(&#39;.py&#39;):
                continue
                
            path = Path(self.coder.abs_root_path(fname))
            content = path.read_text()
            
            # Use AST to find all functions and classes
            try:
                analyzer = CodeAnalyzer(content)
                for node in ast.walk(analyzer.tree):
                    if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                        name = node.name
                        if not name.startswith(&#39;_&#39;):  # Skip private definitions
                            completions.append(name)
                            # Add --level options
                            completions.extend([
                                f&quot;{name} --level=basic&quot;,
                                f&quot;{name} --level=deep&quot;,
                                f&quot;{name} --level=eli5&quot;
                            ])
            except SyntaxError:
                # Fall back to regex for files with syntax errors
                for match in re.finditer(r&#39;(?:def|class)\s+([a-zA-Z_]\w*)&#39;, content):
                    name = match.group(1)
                    if not name.startswith(&#39;_&#39;):
                        completions.append(name)
                        # Add --level options
                        completions.extend([
                            f&quot;{name} --level=basic&quot;,
                            f&quot;{name} --level=deep&quot;,
                            f&quot;{name} --level=eli5&quot;
                        ])
                        
        except Exception as e:
            if self.coder.verbose:
                self.io.tool_error(f&quot;Error getting completions from {fname}: {e}&quot;)
            continue
            
    return sorted(set(completions))  # Remove duplicates

# Register the command with completions
CommandsRegistry.register(&quot;explain&quot;, cmd_explain, completions_explain)</pre>
</div>
<h3>custom_aider/commands/git_commands.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Git-related command extensions&quot;&quot;&quot;

import subprocess
from datetime import datetime
from pathlib import Path

from ..commands_registry import CommandsRegistry

def cmd_glog(self, args):
    &quot;&quot;&quot;Show pretty git log with branch graph and stats
    Usage: /glog [options]
    
    Options:
        -n N     Show last N commits (default: 10)
        --all    Show all branches
        --stat   Show changed files statistics
    &quot;&quot;&quot;
    if not self.coder.repo:
        self.io.tool_error(&quot;No git repository found&quot;)
        return
        
    # Parse arguments
    num_commits = &quot;10&quot;
    show_all = False
    show_stats = False
    
    if args:
        parts = args.split()
        for i, part in enumerate(parts):
            if part == &quot;-n&quot; and i + 1 &lt; len(parts):
                num_commits = parts[i + 1]
            elif part == &quot;--all&quot;:
                show_all = True
            elif part == &quot;--stat&quot;:
                show_stats = True
                
    cmd = [
        &quot;git&quot;, &quot;log&quot;,
        f&quot;-n{num_commits}&quot;,
        &quot;--graph&quot;,
        &quot;--date=format:%Y-%m-%d %H:%M&quot;,
        &quot;--pretty=format:%C(yellow)%h%C(reset) - %C(green)%ad%C(reset) %C(bold blue)%an%C(reset)%C(red)%d%C(reset)%n%s%n&quot;
    ]
    
    if show_all:
        cmd.append(&quot;--all&quot;)
    if show_stats:
        cmd.append(&quot;--stat&quot;)
        
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            self.io.tool_output(result.stdout)
        else:
            self.io.tool_error(f&quot;Git error: {result.stderr}&quot;)
    except Exception as e:
        self.io.tool_error(f&quot;Error running git command: {e}&quot;)

def completions_glog(self):
    &quot;&quot;&quot;Provide completions for glog command&quot;&quot;&quot;
    return [&quot;--all&quot;, &quot;--stat&quot;, &quot;-n&quot;]

# Register commands
CommandsRegistry.register(&quot;glog&quot;, cmd_glog, completions_glog)</pre>
</div>
<h3>custom_aider/commands/load_templated_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for loading parameterized command templates with default values&quot;&quot;&quot;

import os
import json
from pathlib import Path
from ..commands_registry import CommandsRegistry

class TemplateLoader:
    &quot;&quot;&quot;Handles loading and parameterizing command templates&quot;&quot;&quot;
    
    def __init__(self, io):
        self.io = io
        self.templates_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;command_templates&#39; / &#39;load_templated&#39;
        self.templates_dir.mkdir(parents=True, exist_ok=True)
        
    def get_available_templates(self):
        &quot;&quot;&quot;Return list of available template files&quot;&quot;&quot;
        templates = []
        if self.templates_dir.exists():
            templates = [f for f in self.templates_dir.glob(&#39;*.json&#39;) 
                        if f.is_file()]
        return templates
        
    def load_template(self, template_name):
        &quot;&quot;&quot;Load a template file by name&quot;&quot;&quot;
        template_path = self.templates_dir / f&quot;{template_name}.json&quot;
        if not template_path.exists():
            self.io.tool_error(f&quot;Template {template_name} not found&quot;)
            return None
            
        try:
            with open(template_path) as f:
                return json.load(f)
        except json.JSONDecodeError:
            self.io.tool_error(f&quot;Invalid JSON in template {template_name}&quot;)
            return None
            
    def get_parameter_values(self, parameters):
        &quot;&quot;&quot;Interactively collect parameter values from user.
        
        Parameters can be specified in two ways:
        1. Simple string: &quot;param_name&quot;
        2. Dict with default: {&quot;name&quot;: &quot;param_name&quot;, &quot;default&quot;: &quot;default_value&quot;}
        &quot;&quot;&quot;
        values = {}
        for param in parameters:
            # Handle both string params and dict params with defaults
            if isinstance(param, dict):
                param_name = param[&quot;name&quot;]
                default = param.get(&quot;default&quot;, &quot;&quot;)
            else:
                param_name = param
                default = &quot;&quot;
                
            # Build prompt with optional default value
            prompt = f&quot;Enter value for {param_name}&quot;
            if default:
                prompt += f&quot; [{default}]&quot;
            prompt += &quot;: &quot;
            
            value = self.io.prompt_ask(prompt, default=default)
            if value:
                values[param_name] = value
            elif default:
                values[param_name] = default 
            else:
                return None
        return values
        
    def format_commands(self, commands, param_values):
        &quot;&quot;&quot;Format commands with parameter values&quot;&quot;&quot;
        formatted = []
        for cmd in commands:
            try:
                formatted.append(cmd.format(**param_values))
            except KeyError as e:
                self.io.tool_error(f&quot;Missing parameter {e} in template&quot;)
                return None
        return formatted

def cmd_load_templated(self, args):
    &quot;&quot;&quot;Load and execute a parameterized command template
    Usage: /load_templated &lt;template_name&gt;
    
    Load a template file from .extn_aider/command_templates/load_templated/&lt;template_name&gt;.json
    Prompts for parameter values and executes the commands.
    
    Template files should be JSON with this structure:
    {
        &quot;parameters&quot;: [
            &quot;simple_param&quot;,                              # Simple parameter
            {&quot;name&quot;: &quot;param_with_default&quot;, &quot;default&quot;: &quot;default_value&quot;}  # Parameter with default
        ],
        &quot;commands&quot;: [
            &quot;/command1 {simple_param}&quot;,
            &quot;/command2 {simple_param} {param_with_default}&quot;
        ]
    }
    
    Example template (new_api.json):
    {
        &quot;parameters&quot;: [
            {&quot;name&quot;: &quot;endpoint_name&quot;, &quot;default&quot;: &quot;users&quot;},
            {&quot;name&quot;: &quot;http_method&quot;, &quot;default&quot;: &quot;GET&quot;}
        ],
        &quot;commands&quot;: [
            &quot;/add api/{endpoint_name}.py&quot;,
            &quot;/code Create a {http_method} endpoint at /{endpoint_name}&quot;
        ]
    }
    
    Usage:
    &gt; /load_templated new_api
    Enter value for endpoint_name [users]: products  
    Enter value for http_method [GET]: POST
    
    This will execute:
    /add api/products.py
    /code Create a POST endpoint at /products
    &quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please specify a template name&quot;)
        return
        
    template_name = args.strip()
    loader = TemplateLoader(self.io)
    
    template = loader.load_template(template_name)
    if not template:
        templates = loader.get_available_templates()
        if templates:
            self.io.tool_output(&quot;\nAvailable templates:&quot;)
            for t in templates:
                self.io.tool_output(f&quot;  {t.stem}&quot;)
        return
        
    param_values = loader.get_parameter_values(template.get(&#39;parameters&#39;, []))
    if not param_values:
        return
        
    commands = loader.format_commands(template.get(&#39;commands&#39;, []), param_values)
    if not commands:
        return
        
    # Execute each command
    for cmd in commands:
        if cmd.startswith(&#39;/&#39;):
            # Strip the leading / and dispatch command
            cmd_name, *cmd_args = cmd[1:].split(maxsplit=1)
            cmd_args = cmd_args[0] if cmd_args else &#39;&#39;
            
            handler_name = f&quot;cmd_{cmd_name}&quot;
            handler = getattr(self, handler_name, None)
            
            if handler:
                handler(cmd_args)
            else:
                self.io.tool_error(f&quot;Unknown command: {cmd_name}&quot;)
        else:
            # Treat as a message to send
            self.coder.send_message(cmd)

def completions_load_templated(self):
    &quot;&quot;&quot;Completions for load_templated command&quot;&quot;&quot;
    loader = TemplateLoader(self.io)
    templates = loader.get_available_templates()
    return [t.stem for t in templates]
    
# Register the command
CommandsRegistry.register(
    &quot;load_templated&quot;,
    cmd_load_templated,
    completions_load_templated
)</pre>
</div>
<h3>custom_aider/commands/load_templated_script_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for loading and executing script-based command templates&quot;&quot;&quot;

import os
import sys
import importlib.util
from pathlib import Path
from ..commands_registry import CommandsRegistry

def load_script_template(template_name):
    &quot;&quot;&quot;Load a script template by name and return module&quot;&quot;&quot;
    try:
        # Find template directory
        templates_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;command_templates&#39; / &#39;load_templated_script&#39;
        script_path = templates_dir / f&quot;{template_name}.py&quot;

        if not script_path.exists():
            return None, f&quot;Template {template_name} not found&quot;

        # Load module from file
        spec = importlib.util.spec_from_file_location(template_name, script_path)
        module = importlib.util.module_from_spec(spec)
        sys.modules[template_name] = module
        spec.loader.exec_module(module)

        return module, None

    except Exception as e:
        return None, f&quot;Error loading template: {str(e)}&quot;

def get_parameter_values(io, params):
    &quot;&quot;&quot;Collect parameter values interactively&quot;&quot;&quot;
    values = {}
    for name, default in params.items():
        if isinstance(default, bool):
            # Handle boolean parameters
            response = io.confirm_ask(
                f&quot;Enable {name}?&quot;,
                default=&quot;y&quot; if default else &quot;n&quot;
            )
            values[name] = response
        else:
            # Handle string parameters
            value = io.prompt_ask(
                f&quot;Enter value for {name} [{default}]: &quot;,
                default=str(default)
            )
            values[name] = value

    return values

def cmd_load_templated_script(self, args):
    &quot;&quot;&quot;Load and execute a script-based command template
    Usage: /load_templated_script &lt;template_name&gt;
    
    Load a Python script template from .extn_aider/command_templates/load_templated_script/&lt;template_name&gt;.py.
    The script should define:
    1. PARAMS: dict of parameter names and default values
    2. generate_commands(params): function that returns list of commands
    
    Complex examples showing proper path handling:

    1. Basic Project Structure:
    ```python
    from pathlib import Path
    import os

    PARAMS = {
        &quot;project_name&quot;: &quot;myapp&quot;,
        &quot;source_dir&quot;: &quot;src&quot;
    }
    
    def generate_commands(params):
        commands = []
        # Use Path for cross-platform paths
        project_root = Path(params[&quot;project_name&quot;])
        src_dir = project_root / params[&quot;source_dir&quot;]
        
        # Create directory structure
        for dir_name in [&quot;models&quot;, &quot;views&quot;, &quot;controllers&quot;]:
            dir_path = src_dir / dir_name
            commands.append(f&quot;/add {str(dir_path / &#39;__init__.py&#39;)}&quot;)
            
        # Add common files
        readme_path = project_root / &quot;README.md&quot;
        commands.extend([
            f&quot;/add {str(readme_path)}&quot;,
            &quot;/code Create project documentation&quot;
        ])
        
        return commands
    ```

    2. Test File Generator:
    ```python
    from pathlib import Path
    import glob

    PARAMS = {
        &quot;source_dir&quot;: &quot;src&quot;,
        &quot;exclude_patterns&quot;: [&quot;.*&quot;, &quot;__pycache__&quot;]
    }
    
    def find_python_files(source_dir, exclude_patterns):
        &quot; &quot;&quot;Find Python files respecting excludes&quot;&quot; &quot;
        source_path = Path(source_dir)
        py_files = []
        
        for py_file in source_path.rglob(&quot;*.py&quot;):
            if not any(py_file.match(pat) for pat in exclude_patterns):
                py_files.append(py_file)
        
        return py_files
    
    def generate_commands(params):
        commands = []
        # Find source files
        source_files = find_python_files(
            params[&quot;source_dir&quot;],
            params[&quot;exclude_patterns&quot;]
        )
        
        # Create test files
        for source_file in source_files:
            # Generate parallel test structure
            test_file = Path(&quot;tests&quot;) / source_file.relative_to(params[&quot;source_dir&quot;])
            test_file = test_file.parent / f&quot;test_{test_file.name}&quot;
            
            commands.extend([
                f&quot;/add {str(test_file)}&quot;,
                f&quot;/code Create tests for {source_file}&quot;
            ])
            
        return commands
    ```

    3. Multi-component Application:
    ```python
    from pathlib import Path
    import os

    PARAMS = {
        &quot;components&quot;: [&quot;web&quot;, &quot;api&quot;],
        &quot;config_type&quot;: &quot;yaml&quot;
    }
    
    def generate_commands(params):
        commands = []
        
        # Create component directories
        for component in params[&quot;components&quot;]:
            component_dir = Path(component)
            
            # Add component files
            commands.extend([
                f&quot;/add {str(component_dir / &#39;__init__.py&#39;)}&quot;,
                f&quot;/add {str(component_dir / &#39;main.py&#39;)}&quot;
            ])
            
            # Add component config
            if params[&quot;config_type&quot;] == &quot;yaml&quot;:
                config_file = component_dir / &quot;config.yaml&quot;
            else:
                config_file = component_dir / &quot;.env&quot;
                
            commands.append(f&quot;/add {str(config_file)}&quot;)
        
        return commands
    ```

    Key path handling tips:
    1. Use pathlib.Path for cross-platform compatibility
    2. Join paths with / operator: Path(&quot;base&quot;) / &quot;subdir&quot; / &quot;file.py&quot;
    3. Convert Path to string when needed: str(path)
    4. Use .resolve() for absolute paths
    5. Use .relative_to() for relative paths
    6. Check parts with path.parts or path.name
    7. Use .rglob() for recursive file finding
    8. Use .match() for pattern matching
    9. Handle parent directories: path.parent
    10. Create parallel directory structures
    &quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please specify a template name&quot;)
        return

    template_name = args.strip()

    # Load the template module
    module, error = load_script_template(template_name)
    if error:
        self.io.tool_error(error)
        available = Path.cwd() / &#39;.extn_aider&#39; / &#39;command_templates&#39; / &#39;load_templated_script&#39;
        if available.exists():
            self.io.tool_output(&quot;\nAvailable templates:&quot;)
            for f in available.glob(&quot;*.py&quot;):
                if not f.name.startswith(&quot;_&quot;):
                    self.io.tool_output(f&quot;  {f.stem}&quot;)
        return

    # Verify required attributes
    if not hasattr(module, &#39;PARAMS&#39;) or not hasattr(module, &#39;generate_commands&#39;):
        self.io.tool_error(
            f&quot;Template {template_name} must define PARAMS dict and generate_commands function&quot;
        )
        return

    # Get parameter values
    params = get_parameter_values(self.io, module.PARAMS)
    if not params:
        return

    try:
        # Generate commands
        commands = module.generate_commands(params)
        if not commands:
            self.io.tool_error(&quot;Template generated no commands&quot;)
            return

        # Show commands that will be executed
        self.io.tool_output(&quot;\nCommands to execute:&quot;)
        for cmd in commands:
            self.io.tool_output(f&quot;  {cmd}&quot;)

        if not self.io.confirm_ask(&quot;\nProceed with execution?&quot;, default=&quot;y&quot;):
            return

        # Execute each command
        for cmd in commands:
            if cmd.startswith(&#39;/code &#39;):
                # Strip the leading /code and dispatch code command
                cmd_args = cmd[5:].strip()
                # Treat as a message to send
                self.coder.send_message(cmd_args)
            elif cmd.startswith(&#39;/&#39;):
                # Strip the leading / and dispatch command
                cmd_name, *cmd_args = cmd[1:].split(maxsplit=1)
                cmd_args = cmd_args[0] if cmd_args else &#39;&#39;

                handler_name = f&quot;cmd_{cmd_name}&quot;
                handler = getattr(self, handler_name, None)

                if handler:
                    handler(cmd_args)
                else:
                    self.io.tool_error(f&quot;Unknown command: {cmd_name}&quot;)
            else:
                # Treat as a message to send
                self.coder.send_message(cmd)

    except Exception as e:
        self.io.tool_error(f&quot;Error executing template: {str(e)}&quot;)

def completions_load_templated_script(self):
    &quot;&quot;&quot;Provide completions for script templates&quot;&quot;&quot;
    templates_dir = Path.cwd() / &#39;.extn_aider&#39; / &#39;command_templates&#39; / &#39;load_templated_script&#39;
    if templates_dir.exists():
        return [f.stem for f in templates_dir.glob(&quot;*.py&quot;) 
                if not f.name.startswith(&quot;_&quot;)]
    return []

# Register the command
CommandsRegistry.register(
    &quot;load_templated_script&quot;,
    cmd_load_templated_script,
    completions_load_templated_script
)</pre>
</div>
<h3>custom_aider/commands/timemachine_command.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Command for intelligent exploration of code history&quot;&quot;&quot;

import re
from datetime import datetime, timedelta
from pathlib import Path
from ..commands_registry import CommandsRegistry

class CodeHistorian:
    &quot;&quot;&quot;Analyzes and presents code history intelligently&quot;&quot;&quot;
    
    def __init__(self, repo, io):
        self.repo = repo
        self.io = io
        
    def parse_time_period(self, time_spec):
        &quot;&quot;&quot;Parse time specification into a start date&quot;&quot;&quot;
        if not time_spec:
            return None
            
        # Handle relative time periods
        if match := re.match(r&#39;last\s+(\d+)\s+(day|month|year)s?&#39;, time_spec.lower()):
            number, unit = match.groups()
            number = int(number)
            # Use UTC for consistency with git timestamps
            now = datetime.now().replace(tzinfo=None)
            
            if unit == &#39;day&#39;:
                return now - timedelta(days=number)
            elif unit == &#39;month&#39;:
                return now - timedelta(days=number * 30)
            elif unit == &#39;year&#39;:
                return now - timedelta(days=number * 365)
                
        # Handle &quot;before/after&quot; references
        if match := re.match(r&#39;(before|after)\s+(.+)&#39;, time_spec.lower()):
            direction, reference = match.groups()
            
            # Look for commit with reference in message
            for commit in self.repo.repo.iter_commits():
                if reference.lower() in commit.message.lower():
                    if direction == &#39;before&#39;:
                        return commit.authored_datetime
                    else:
                        return commit.authored_datetime
                        
        return None
        
    def get_file_history(self, filepath, since_date=None):
        &quot;&quot;&quot;Get commit history for a specific file&quot;&quot;&quot;
        history = []
        try:
            commits = self.repo.repo.iter_commits(paths=filepath)
            for commit in commits:
                # Convert to naive datetime for comparison
                commit_date = commit.authored_datetime.replace(tzinfo=None)
                if since_date and commit_date &lt; since_date:
                    continue
                    
                # Get diff for this file in this commit
                diff = commit.diff(commit.parents[0] if commit.parents else None)
                file_diff = next((d for d in diff if d.a_path == filepath or d.b_path == filepath), None)
                
                if file_diff:
                    history.append({
                        &#39;commit&#39;: commit,
                        &#39;diff&#39;: file_diff,
                        &#39;date&#39;: commit.authored_datetime,
                        &#39;author&#39;: commit.author.name,
                        &#39;message&#39;: commit.message.strip()
                    })
        except Exception as e:
            self.io.tool_error(f&quot;Error getting history: {e}&quot;)
            
        return history
        
    def find_related_changes(self, filepath, history):
        &quot;&quot;&quot;Find related changes in other files&quot;&quot;&quot;
        related = {}
        base_name = Path(filepath).stem
        
        for entry in history:
            commit = entry[&#39;commit&#39;]
            
            # Look for related files changed in same commits
            for diff in commit.diff(commit.parents[0] if commit.parents else None):
                other_path = diff.a_path or diff.b_path
                if other_path != filepath:
                    # Check if file looks related
                    other_name = Path(other_path).stem
                    if (base_name in other_name or 
                        other_name in base_name or
                        &#39;test&#39; in other_path.lower()):
                        related[other_path] = related.get(other_path, 0) + 1
                        
        return related
        
    def analyze_changes(self, filepath, since_date=None):
        &quot;&quot;&quot;Analyze evolution of code in a file&quot;&quot;&quot;
        history = self.get_file_history(filepath, since_date)
        if not history:
            return None
            
        # Find related files
        related = self.find_related_changes(filepath, history)
        
        # Group changes by type
        features = []
        bugs = []
        tests = []
        refactors = []
        other = []
        
        for entry in history:
            msg = entry[&#39;message&#39;].lower()
            if &#39;feat&#39; in msg or &#39;add&#39; in msg or &#39;new&#39; in msg:
                features.append(entry)
            elif &#39;fix&#39; in msg or &#39;bug&#39; in msg or &#39;issue&#39; in msg:
                bugs.append(entry)
            elif &#39;test&#39; in msg:
                tests.append(entry)
            elif &#39;refactor&#39; in msg or &#39;clean&#39; in msg:
                refactors.append(entry)
            else:
                other.append(entry)
                
        return {
            &#39;history&#39;: history,
            &#39;related_files&#39;: related,
            &#39;features&#39;: features,
            &#39;bugs&#39;: bugs, 
            &#39;tests&#39;: tests,
            &#39;refactors&#39;: refactors,
            &#39;other&#39;: other
        }
        
    def format_results(self, results, filepath):
        &quot;&quot;&quot;Format analysis results into readable output&quot;&quot;&quot;
        if not results:
            return &quot;No history found for the specified criteria.&quot;
            
        output = []
        
        # Overview section
        output.append(f&quot;\nCode Evolution Analysis for: {filepath}&quot;)
        output.append(&quot;=&quot; * 50)
        
        # Timeline summary
        output.append(&quot;\nTimeline Summary:&quot;)
        output.append(&quot;-&quot; * 20)
        first = results[&#39;history&#39;][-1][&#39;date&#39;]
        last = results[&#39;history&#39;][0][&#39;date&#39;]
        total = len(results[&#39;history&#39;])
        output.append(f&quot;First change: {first.strftime(&#39;%Y-%m-%d&#39;)}&quot;)
        output.append(f&quot;Latest change: {last.strftime(&#39;%Y-%m-%d&#39;)}&quot;)
        output.append(f&quot;Total changes: {total}&quot;)
        
        # Feature development
        if results[&#39;features&#39;]:
            output.append(&quot;\nFeature Development:&quot;)
            output.append(&quot;-&quot; * 20)
            for entry in results[&#39;features&#39;]:
                date = entry[&#39;date&#39;].strftime(&#39;%Y-%m-%d&#39;)
                output.append(f&quot;{date} - {entry[&#39;message&#39;].split(&#39;\n&#39;)[0]}&quot;)
                
        # Bug fixes
        if results[&#39;bugs&#39;]:
            output.append(&quot;\nBug Fixes:&quot;)
            output.append(&quot;-&quot; * 20)
            for entry in results[&#39;bugs&#39;]:
                date = entry[&#39;date&#39;].strftime(&#39;%Y-%m-%d&#39;)
                output.append(f&quot;{date} - {entry[&#39;message&#39;].split(&#39;\n&#39;)[0]}&quot;)
                
        # Test changes
        if results[&#39;tests&#39;]:
            output.append(&quot;\nTest Development:&quot;)
            output.append(&quot;-&quot; * 20)
            for entry in results[&#39;tests&#39;]:
                date = entry[&#39;date&#39;].strftime(&#39;%Y-%m-%d&#39;)
                output.append(f&quot;{date} - {entry[&#39;message&#39;].split(&#39;\n&#39;)[0]}&quot;)
                
        # Related files
        if results[&#39;related_files&#39;]:
            output.append(&quot;\nCommonly Changed Together:&quot;)
            output.append(&quot;-&quot; * 20)
            for file, count in sorted(results[&#39;related_files&#39;].items(), 
                                    key=lambda x: x[1], reverse=True)[:5]:
                output.append(f&quot;{file} ({count} times)&quot;)
                
        # Contributors
        contributors = {}
        for entry in results[&#39;history&#39;]:
            contributors[entry[&#39;author&#39;]] = contributors.get(entry[&#39;author&#39;], 0) + 1
            
        output.append(&quot;\nContributors:&quot;)
        output.append(&quot;-&quot; * 20)
        for author, count in sorted(contributors.items(), 
                                  key=lambda x: x[1], reverse=True):
            output.append(f&quot;{author}: {count} changes&quot;)
            
        return &quot;\n&quot;.join(output)

def cmd_timemachine(self, args):
    &quot;&quot;&quot;Intelligent exploration of code history
    Usage: /timemachine &lt;function/feature&gt; [--when time_period]
    
    Beyond simple git history, shows:
    - When and why code evolved
    - Related bug fixes over time  
    - Feature development timeline
    - Key commits that modified behavior
    - Contributors and their changes
    - Test changes that accompanied code changes
    
    Examples:
    /timemachine login_flow --when &quot;last 3 months&quot;
    /timemachine payment.py --when &quot;before refactor&quot;
    /timemachine database.init --when &quot;after bug #123&quot;
    
    Like having a historian explain how your code evolved.
    &quot;&quot;&quot;
    if not args.strip():
        self.io.tool_error(&quot;Please specify what to analyze&quot;)
        return
        
    if not self.coder.repo:
        self.io.tool_error(&quot;No git repository found&quot;)
        return
        
    # Parse arguments
    parts = args.split(&#39;--when&#39;)
    target = parts[0].strip()
    when = parts[1].strip() if len(parts) &gt; 1 else None
    
    # Initialize historian
    historian = CodeHistorian(self.coder.repo, self.io)
    
    # Get date range if specified
    since_date = historian.parse_time_period(when) if when else None
    
    # Find target file/path
    found = False
    for fname in self.coder.get_all_relative_files():
        if (target in fname or
            target == Path(fname).stem or 
            target in Path(fname).stem):
            
            self.io.tool_output(f&quot;\nAnalyzing history of {fname}...&quot;)
            results = historian.analyze_changes(fname, since_date)
            output = historian.format_results(results, fname)
            self.io.tool_output(output)
            found = True
            
    if not found:
        self.io.tool_error(
            f&quot;Could not find any files matching &#39;{target}&#39;. &quot;
            &quot;Try using a more specific path or filename.&quot;
        )

def completions_timemachine(self):
    &quot;&quot;&quot;Provide completions for timemachine command&quot;&quot;&quot;
    # Get list of files
    files = []
    if self.coder.repo:
        files = self.coder.get_all_relative_files()
        
    # Add common time periods
    time_periods = [
        &#39;last 3 months&#39;,
        &#39;last 6 months&#39;, 
        &#39;last year&#39;,
        &#39;last 2 years&#39;
    ]
    
    completions = []
    
    # Add file completions
    for f in files:
        name = f
        stem = Path(f).stem
        completions.append(name)
        completions.append(stem)
        # Add with time periods
        for period in time_periods:
            completions.append(f&quot;{name} --when {period}&quot;)
            completions.append(f&quot;{stem} --when {period}&quot;)
            
    return sorted(set(completions))

# Register command
CommandsRegistry.register(
    &quot;timemachine&quot;,
    cmd_timemachine,
    completions_timemachine
)
</pre>
</div>
<h3>custom_aider/commands/utility_commands.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Utility command extensions&quot;&quot;&quot;

from pathlib import Path
from ..commands_registry import CommandsRegistry

def cmd_files(self, args):
    &quot;&quot;&quot;List all files with details
    Usage: /files [pattern]
    
    Shows files in chat with their sizes and last modified times
    Optional pattern to filter files
    &quot;&quot;&quot;
    files = self.coder.get_inchat_relative_files()
    if not files:
        self.io.tool_output(&quot;No files in chat&quot;)
        return
        
    pattern = args.strip() if args else None
    if pattern:
        files = [f for f in files if pattern in f]
        
    self.io.tool_output(&quot;\nFiles in chat:&quot;)
    for fname in sorted(files):
        try:
            path = Path(self.coder.abs_root_path(fname))
            stats = path.stat()
            size = stats.st_size
            modified = stats.st_mtime
            
            # Format size
            if size &lt; 1024:
                size_str = f&quot;{size}B&quot;
            elif size &lt; 1024 * 1024:
                size_str = f&quot;{size/1024:.1f}KB&quot;
            else:
                size_str = f&quot;{size/1024/1024:.1f}MB&quot;
                
            # Format time
            from datetime import datetime
            time_str = datetime.fromtimestamp(modified).strftime(&quot;%Y-%m-%d %H:%M&quot;)
            
            self.io.tool_output(f&quot;{size_str:&gt;8} {time_str} {fname}&quot;)
            
        except Exception as e:
            self.io.tool_error(f&quot;Error getting info for {fname}: {e}&quot;)

def cmd_stats(self, args):
    &quot;&quot;&quot;Show statistics about files in chat
    Usage: /stats
    
    Shows total lines, words, characters for all files in chat
    Breaks down by file type
    &quot;&quot;&quot;
    files = self.coder.get_inchat_relative_files()
    if not files:
        self.io.tool_output(&quot;No files in chat&quot;)
        return
        
    stats = {
        &#39;total&#39;: {&#39;files&#39;: 0, &#39;lines&#39;: 0, &#39;words&#39;: 0, &#39;chars&#39;: 0},
        &#39;by_type&#39;: {}
    }
    
    for fname in files:
        try:
            path = Path(self.coder.abs_root_path(fname))
            content = path.read_text()
            
            # Get extension
            ext = path.suffix.lower() or &#39;no_ext&#39;
            if ext not in stats[&#39;by_type&#39;]:
                stats[&#39;by_type&#39;][ext] = {
                    &#39;files&#39;: 0, &#39;lines&#39;: 0, &#39;words&#39;: 0, &#39;chars&#39;: 0
                }
                
            # Calculate stats
            lines = len(content.splitlines())
            words = len(content.split())
            chars = len(content)
            
            # Update totals
            stats[&#39;total&#39;][&#39;files&#39;] += 1
            stats[&#39;total&#39;][&#39;lines&#39;] += lines
            stats[&#39;total&#39;][&#39;words&#39;] += words
            stats[&#39;total&#39;][&#39;chars&#39;] += chars
            
            # Update by type
            stats[&#39;by_type&#39;][ext][&#39;files&#39;] += 1
            stats[&#39;by_type&#39;][ext][&#39;lines&#39;] += lines
            stats[&#39;by_type&#39;][ext][&#39;words&#39;] += words
            stats[&#39;by_type&#39;][ext][&#39;chars&#39;] += chars
            
        except Exception as e:
            self.io.tool_error(f&quot;Error processing {fname}: {e}&quot;)
            
    # Show results
    self.io.tool_output(&quot;\nTotal Statistics:&quot;)
    self.io.tool_output(f&quot;Files: {stats[&#39;total&#39;][&#39;files&#39;]}&quot;)
    self.io.tool_output(f&quot;Lines: {stats[&#39;total&#39;][&#39;lines&#39;]:,}&quot;)
    self.io.tool_output(f&quot;Words: {stats[&#39;total&#39;][&#39;words&#39;]:,}&quot;)
    self.io.tool_output(f&quot;Chars: {stats[&#39;total&#39;][&#39;chars&#39;]:,}&quot;)
    
    self.io.tool_output(&quot;\nBy File Type:&quot;)
    for ext, type_stats in sorted(stats[&#39;by_type&#39;].items()):
        self.io.tool_output(f&quot;\n{ext}:&quot;)
        self.io.tool_output(f&quot;  Files: {type_stats[&#39;files&#39;]}&quot;)
        self.io.tool_output(f&quot;  Lines: {type_stats[&#39;lines&#39;]:,}&quot;)
        self.io.tool_output(f&quot;  Words: {type_stats[&#39;words&#39;]:,}&quot;)

# Register commands
CommandsRegistry.register(&quot;files&quot;, cmd_files)
CommandsRegistry.register(&quot;stats&quot;, cmd_stats)</pre>
</div>
<h3>custom_aider/commands_registry.py</h3>
<div class="file-content">
<pre>from typing import Callable, Dict, Optional, List
import inspect

class CommandsRegistry:
    &quot;&quot;&quot;A registry for custom aider commands&quot;&quot;&quot;
    _commands: Dict[str, Callable] = {}
    _completions: Dict[str, Callable] = {}
    _descriptions: Dict[str, str] = {}
    
    @classmethod
    def register(cls, name: str, handler: Callable, completions: Optional[Callable] = None) -&gt; None:
        &quot;&quot;&quot;Register a command handler and optional completions&quot;&quot;&quot;
        print(f&quot;Registering command: {name}&quot;)  # Debug print
        
        if not callable(handler):
            raise TypeError(&quot;Command handler must be callable&quot;)
            
        # Store command docstring as description
        if handler.__doc__:
            cls._descriptions[name] = inspect.cleandoc(handler.__doc__)
            
        cmd_name = f&quot;cmd_{name}&quot;
        cls._commands[cmd_name] = handler
        print(f&quot;Registered command {cmd_name}&quot;)  # Debug print
        
        if completions:
            if not callable(completions):
                raise TypeError(&quot;Completions must be callable&quot;)
            cls._completions[f&quot;completions_{name}&quot;] = completions
            print(f&quot;Registered completions for {name}&quot;)  # Debug print

    @classmethod
    def install_commands(cls, commands_instance) -&gt; None:
        &quot;&quot;&quot;Install all registered commands on a Commands instance&quot;&quot;&quot;
        print(f&quot;Installing {len(cls._commands)} commands...&quot;)  # Debug print
        
        for name, func in cls._commands.items():
            if hasattr(commands_instance.__class__, name):
                print(f&quot;Warning: Command {name} already exists&quot;)
                continue
                
            try:
                setattr(commands_instance.__class__, name, func)
                print(f&quot;Installed command: {name}&quot;)  # Debug print
            except Exception as e:
                print(f&quot;Error installing command {name}: {e}&quot;)
                
        for name, func in cls._completions.items():
            if not hasattr(commands_instance.__class__, name):
                setattr(commands_instance.__class__, name, func)
                print(f&quot;Installed completions: {name}&quot;)  # Debug print

        print(&quot;Finished installing commands&quot;)  # Debug print

        
    @classmethod
    def list_commands(cls) -&gt; List[str]:
        &quot;&quot;&quot;List all registered command names&quot;&quot;&quot;
        return [name[4:] for name in cls._commands.keys()]  # Strip cmd_ prefix
        
    @classmethod
    def get_command(cls, name: str) -&gt; Optional[Callable]:
        &quot;&quot;&quot;Get a command by name&quot;&quot;&quot;
        return cls._commands.get(f&quot;cmd_{name}&quot;)
        
    @classmethod
    def get_description(cls, name: str) -&gt; str:
        &quot;&quot;&quot;Get command description&quot;&quot;&quot;
        return cls._descriptions.get(name, &quot;No description available&quot;)
        
    @classmethod
    def remove_command(cls, name: str) -&gt; None:
        &quot;&quot;&quot;Remove a registered command&quot;&quot;&quot;
        cls._commands.pop(f&quot;cmd_{name}&quot;, None)
        cls._completions.pop(f&quot;completions_{name}&quot;, None)
        cls._descriptions.pop(name, None)

    @classmethod
    def clear(cls) -&gt; None:
        &quot;&quot;&quot;Clear all registered commands&quot;&quot;&quot;
        cls._commands.clear()
        cls._completions.clear()
        cls._descriptions.clear()</pre>
</div>
<h3>custom_aider/custom_aider_main.py</h3>
<div class="file-content">
<pre>import sys
from pathlib import Path
from aider.main import main as aider_main
from .commands_registry import CommandsRegistry
import importlib

def load_command_modules():
    &quot;&quot;&quot;Dynamically load all command modules&quot;&quot;&quot;
    print(&quot;Loading command modules...&quot;)  # Debug output
    commands_dir = Path(__file__).parent / &quot;commands&quot;
    if not commands_dir.exists():
        print(f&quot;Commands directory not found: {commands_dir}&quot;)  # Debug output
        return
        
    # Exclude __init__.py and files starting with _
    command_files = [
        f for f in commands_dir.glob(&quot;*.py&quot;)
        if not f.name.startswith(&quot;_&quot;) and f.name != &quot;__init__.py&quot;
    ]
    
    for command_file in command_files:
        module_name = f&quot;custom_aider.commands.{command_file.stem}&quot;
        try:
            importlib.import_module(module_name)
            print(f&quot;Loaded command module: {module_name}&quot;)
        except Exception as e:
            print(f&quot;Error loading command module {module_name}: {e}&quot;)

def initialize_custom_aider():
    &quot;&quot;&quot;Initialize the custom aider environment&quot;&quot;&quot;
    # First override the Coder class
    import aider.coders as coders
    from .custom_coder import CustomCoder
    coders.Coder = CustomCoder
    
    # Then load command modules to register commands
    load_command_modules()
    
    # Log loaded commands
    commands = CommandsRegistry.list_commands()
    print(f&quot;Loaded custom commands: {&#39;, &#39;.join(commands)}&quot;)

def custom_main():
    &quot;&quot;&quot;Run custom aider with extensions&quot;&quot;&quot;
    try:
        initialize_custom_aider()
        return aider_main()
    except Exception as e:
        print(f&quot;Error in custom aider: {e}&quot;)
        raise

if __name__ == &quot;__main__&quot;:
    custom_main()</pre>
</div>
<h3>custom_aider/custom_coder.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Custom coder implementation with command registry support&quot;&quot;&quot;
import logging
from typing import Optional, ClassVar
from aider.coders.base_coder import Coder as BaseCoder
from .commands_registry import CommandsRegistry

logger = logging.getLogger(__name__)

class CustomCoder(BaseCoder):
    &quot;&quot;&quot;Enhanced Coder with custom command support&quot;&quot;&quot;
    
    _current_coder: ClassVar[Optional[&#39;CustomCoder&#39;]] = None
    
    def __init__(self, *args, **kwargs):
        print(&quot;CustomCoder.__init__ called&quot;)  # Debug print
        super().__init__(*args, **kwargs)
    
    @classmethod
    def create(cls, *args, **kwargs):
        &quot;&quot;&quot;Create a coder instance with custom commands&quot;&quot;&quot;
        print(&quot;CustomCoder.create called&quot;)  # Debug print
        
        # Create coder instance
        coder = super().create(*args, **kwargs)
        print(f&quot;Created coder: {coder.__class__}&quot;)  # Debug print
        
        # Install custom commands
        if hasattr(coder, &#39;commands&#39;):
            print(f&quot;Found commands on coder&quot;) # Debug print
            registered_commands = CommandsRegistry.list_commands()
            print(f&quot;Installing commands: {registered_commands}&quot;)  # Debug print
            CommandsRegistry.install_commands(coder.commands)
            print(&quot;Finished installing commands&quot;)  # Debug print
        else:
            print(&quot;No commands attribute found on coder&quot;)  # Debug print
            
        # Store reference
        cls._current_coder = coder
        return coder</pre>
</div>
<h3>custom_aider/docs/addlessonlist.py</h3>
<div class="file-content">
<pre>import glob
basehtmlfilename = &quot;markdown-viewer-with-filelist.html&quot;
outfilename = &quot;index.html&quot;

with open(basehtmlfilename, &#39;r&#39;, encoding=&quot;utf8&quot;) as readfile:
    outfiletxt = readfile.read()
    
filenames = glob.glob(&#39;*.md&#39;)
fns=&#39;&#39;
for fname in filenames:
    fns=fns + &#39;&quot;&#39; + fname + &#39;&quot;&#39; + &#39;,\n&#39;
print(fns)

with open(outfilename, &#39;w&#39;, encoding=&quot;utf8&quot;) as outfile:    
    outfiletxt = outfiletxt.replace(&#39;&lt;&lt;&lt;&lt;&lt;&lt;lessons&gt;&gt;&gt;&gt;&gt;&gt;&#39;,fns)
    outfile.write(outfiletxt)</pre>
</div>
<h3>custom_aider/docs/extension-docs.md</h3>
<div class="file-content">
<pre># Aider Extension System Technical Documentation

This document explains how the Aider extension system works internally, providing technical details for developers who want to understand or extend the system.

## Overview

The extension system is built around several key components that work together to add new functionality to Aider:

1. Command Registry - Central registration and management of commands
2. Custom Coder - Enhanced coder class with extension support
3. Monkey Patching - System for safely extending Aider&#39;s core functionality
4. Dynamic Command Loading - Automatic discovery and loading of command modules

## Core Components

### 1. Commands Registry (`commands_registry.py`)

The `CommandsRegistry` is a central class that manages all custom commands:

```python
class CommandsRegistry:
    _commands: Dict[str, Callable] = {}
    _completions: Dict[str, Callable] = {}
    _descriptions: Dict[str, str] = {}

    @classmethod
    def register(cls, name: str, handler: Callable, completions: Optional[Callable] = None):
        # Registers a new command and its optional completions
        cmd_name = f&quot;cmd_{name}&quot;
        cls._commands[cmd_name] = handler
        if completions:
            cls._completions[f&quot;completions_{name}&quot;] = completions
```

Key features:
- Centralized command registration
- Support for command completions
- Automatic docstring extraction for help text
- Safe command installation checking

### 2. Custom Coder (`custom_coder.py`)

The `CustomCoder` extends Aider&#39;s base `Coder` class to support extensions:

```python
class CustomCoder(BaseCoder):
    _current_coder: ClassVar[Optional[&#39;CustomCoder&#39;]] = None
    
    @classmethod
    def create(cls, *args, **kwargs):
        coder = super().create(*args, **kwargs)
        if hasattr(coder, &#39;commands&#39;):
            CommandsRegistry.install_commands(coder.commands)
        cls._current_coder = coder
        return coder
```

Features:
- Maintains compatibility with base Aider functionality
- Installs custom commands on creation
- Provides extension points for new features

### 3. Monkey Patching (`monkey_patch.py`)

The monkey patching system allows safe modification of Aider&#39;s core classes:

```python
def monkey_patch_aider():
    # Add custom_aider directory to Python path
    custom_aider_dir = Path(__file__).parent
    if str(custom_aider_dir) not in sys.path:
        sys.path.insert(0, str(custom_aider_dir))
    
    # Patch Aider&#39;s coder classes
    from custom_aider.custom_coder import CustomCoder
    import aider.coders as coders
    coders.Coder = CustomCoder
```

Purpose:
- Ensures extensions are loaded before Aider&#39;s core
- Maintains consistent state across the application
- Provides clean integration points

## Command Implementation

### Command Structure

Each command module should follow this structure:

```python
from ..commands_registry import CommandsRegistry

def cmd_commandname(self, args):
    &quot;&quot;&quot;Command documentation
    Usage: /commandname &lt;args&gt;
    
    Detailed description of the command.
    &quot;&quot;&quot;
    # Command implementation
    pass

def completions_commandname(self):
    &quot;&quot;&quot;Return list of possible completions&quot;&quot;&quot;
    return [&quot;completion1&quot;, &quot;completion2&quot;]

# Register the command
CommandsRegistry.register(&quot;commandname&quot;, cmd_commandname, completions_commandname)
```

### Command Types

1. **Simple Commands**
   ```python
   def cmd_simple(self, args):
       self.io.tool_output(&quot;Simple command output&quot;)
   ```

2. **Interactive Commands**
   ```python
   def cmd_interactive(self, args):
       if self.io.confirm_ask(&quot;Continue?&quot;, default=&quot;y&quot;):
           # Perform action
           pass
   ```

3. **File-handling Commands**
   ```python
   def cmd_filehandler(self, args):
       for fname in self.coder.get_inchat_relative_files():
           path = Path(self.coder.abs_root_path(fname))
           # Process file
   ```

## Extension Initialization Flow

1. **Early Initialization**
   ```python
   # main.py
   from custom_aider.monkey_patch import monkey_patch_aider
   monkey_patch_aider()
   ```

2. **Command Loading**
   ```python
   def load_command_modules():
       commands_dir = Path(__file__).parent / &quot;commands&quot;
       for command_file in commands_dir.glob(&quot;*.py&quot;):
           if not command_file.name.startswith(&quot;_&quot;):
               importlib.import_module(f&quot;custom_aider.commands.{command_file.stem}&quot;)
   ```

3. **Command Installation**
   ```python
   def initialize_custom_aider():
       # Override Coder class
       import aider.coders as coders
       from .custom_coder import CustomCoder
       coders.Coder = CustomCoder
       
       # Load command modules
       load_command_modules()
   ```

## Adding New Commands

### 1. Create Command Module

Create a new Python file in the `commands` directory:

```python
# commands/my_command.py
from ..commands_registry import CommandsRegistry

def cmd_mycommand(self, args):
    &quot;&quot;&quot;My new command description
    Usage: /mycommand &lt;args&gt;
    &quot;&quot;&quot;
    # Implementation
    pass

CommandsRegistry.register(&quot;mycommand&quot;, cmd_mycommand)
```

### 2. Command Features

Commands can access:
- `self.coder` - The `CustomCoder` instance
- `self.io` - Input/output interface
- `self.coder.repo` - Git repository (if available)
- `self.coder.main_model` - Current language model

### 3. Best Practices

1. **Error Handling**
   ```python
   try:
       # Command logic
   except Exception as e:
       self.io.tool_error(f&quot;Error: {e}&quot;)
       return
   ```

2. **Input Validation**
   ```python
   if not args.strip():
       self.io.tool_error(&quot;Please provide required arguments&quot;)
       return
   ```

3. **Progress Feedback**
   ```python
   self.io.tool_output(&quot;Processing...&quot;)
   # Long operation
   self.io.tool_output(&quot;Done!&quot;)
   ```

## GUI Integration

The extension system supports multiple GUI frameworks:

### 1. Tkinter Integration
```python
class TkinterEditor:
    def __init__(self, initial_text=&quot;&quot;):
        self.root = tk.Tk()
        # Setup GUI
```

### 2. Streamlit Integration
```python
def create_streamlit_app():
    import streamlit as st
    # Define Streamlit interface
```

## Data Storage

The extension uses the following directories for data storage:

- **`.extn_aider/rags/`**: Stores RAG (Retrieval Augmented Generation) indexes.  Each RAG is stored in its own subdirectory within this folder, named after the RAG&#39;s nickname.
- **`.extn_aider/temp/context_backup/`**: Stores backups of the chat context.  Backups are saved as JSON files with timestamps in the filename.
- **`.extn_aider/temp/context/`**: Stores HTML files generated by the `/context_create` command.
- **`.extn_aider/temp/web/`**: Stores content scraped from URLs using the `/zweb` command.
- **`.extn_aider/temp/backups/`**: Stores backups of files dropped from the chat using the `/zdrop` command.
- **`.extn_aider/explanations/`**: Stores code explanations generated by the `/explain` command.
- **`.extn_aider/command_templates/load_templated/`**: Stores JSON-based command templates for the `/load_templated` command.
- **`.extn_aider/command_templates/load_templated_script/`**: Stores Python script-based command templates for the `/load_templated_script` command.


Best practices for storage:
1. Use appropriate paths for global vs project data
2. Create directories as needed
3. Clean up temporary files
4. Handle storage errors gracefully

## Testing Extensions

### 1. Unit Testing Commands

```python
def test_command():
    coder = CustomCoder.create()
    result = coder.commands.cmd_mycommand(&quot;test args&quot;)
    assert result == expected_output
```

### 2. Integration Testing

```python
def test_extension_flow():
    initialize_custom_aider()
    # Test complete flow
```

## Debugging Tips

1. Enable debug output:
   ```python
   self.coder.verbose = True
   ```

2. Use logging:
   ```python
   import logging
   logger = logging.getLogger(__name__)
   logger.debug(&quot;Debug info&quot;)
   ```

3. Check command registration:
   ```python
   print(CommandsRegistry.list_commands())
   ```

## Common Issues and Solutions

1. **Command Not Found**
   - Check if command module is in the correct directory
   - Verify command registration syntax
   - Check for import errors in the module

2. **Completion Not Working**
   - Verify completion function is registered
   - Check completion function return value
   - Debug completion function logic

3. **GUI Issues**
   - Check required packages are installed
   - Verify GUI framework compatibility
   - Handle GUI events properly

## Best Practices Summary

1. Follow consistent command naming
2. Provide clear documentation
3. Handle errors gracefully
4. Give user feedback for long operations
5. Clean up resources properly
6. Test thoroughly
7. Log appropriately
8. Use appropriate storage locations
9. Validate inputs
10. Support command completion where appropriate

## Available Commands

This section provides a summary of the available commands within the extension.  For detailed usage instructions and examples, refer to the individual command files within the `custom_aider/commands` directory.

### Document Processing Commands
- `/createragfromdoc`: Create a RAG index from a document.
- `/queryragfromdoc`: Query an existing RAG index.
- `/listrag`: List available RAG indexes.
- `/deleterag`: Delete a RAG index.

### Enhanced Chat Commands
- `/customchat`: Send a message with keyword substitution.
- `/clip-edit`: Apply code edits from the clipboard.
- `/editor_tkinter`: Open the enhanced Tkinter editor.

### Git Integration Commands
- `/glog`: Show a Git log with graph and statistics.
- `/zadd`: Add files to Git staging area with status check.
- `/zcommit`: Commit changes with statistics in the message.
- `/zdrop`: Remove files from the chat with backup.

### Context Management Commands
- `/context_show`: Display the current chat context as HTML.
- `/context_backup`: Save a backup of the chat context.
- `/context_load`: Load a chat context from a backup file.
- `/context_create`: Create an interactive context view with export capabilities.

### Web and Voice Commands
- `/zweb`: Fetch content from a URL with retry mechanism.
- `/zvoice`: Use voice input with transcription confidence check.

### Template Loading Commands
- `/load_templated`: Load and execute a parameterized command template.
- `/load_templated_script`: Load and execute a script-based command template.

### AIChat API Commands
- `/aichat_rag_query`: Query a RAG using the AIChat API.

### Time Machine Command
- `/timemachine`: Explore code history intelligently.

### Utility Commands
- `/files`: List files with details.
- `/stats`: Show file statistics.

</pre>
</div>
<h3>custom_aider/docs/index.html</h3>
<div class="file-content">
<pre>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;Modern Markdown Viewer&lt;/title&gt;
        &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/marked/2.1.3/marked.min.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js&quot;&gt;&lt;/script&gt;
        &lt;link
            rel=&quot;stylesheet&quot;
            href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css&quot;
        /&gt;
        &lt;style&gt;
            @import url(&quot;https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&amp;display=swap&quot;);

            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                font-family: &quot;Inter&quot;, sans-serif;
                background-color: #1e1e1e;
                color: #e0e0e0;
                display: flex;
                height: 100vh;
                overflow: hidden;
            }

            #file-list {
                width: 300px;
                min-width: 200px;
                max-width: 50%;
                height: 100%;
                overflow-y: auto;
                background-color: #252526;
                padding: 20px;
                border-right: 1px solid #333;
                transition: width 0.1s ease;
            }

            #file-list ul {
                list-style-type: none;
            }

            #file-list li {
                cursor: pointer;
                padding: 10px;
                margin-bottom: 5px;
                background-color: #2d2d2d;
                border-radius: 5px;
                transition: all 0.3s ease;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            #file-list li:hover {
                background-color: #3a3a3a;
                transform: translateX(5px);
            }

            #resizer {
                width: 10px;
                height: 100%;
                background-color: #333;
                cursor: ew-resize;
            }

            #markdown-content {
                flex-grow: 1;
                padding: 30px;
                overflow-y: auto;
            }

            #content {
                max-width: 800px;
                margin: 0 auto;
                line-height: 1.6;
            }

            #content h1,
            #content h2,
            #content h3,
            #content h4,
            #content h5,
            #content h6 {
                margin-top: 1.5em;
                margin-bottom: 0.5em;
                color: #61afef;
            }

            #content p {
                margin-bottom: 1em;
            }

            #content code {
                background-color: #2c313a;
                padding: 2px 4px;
                border-radius: 3px;
                font-family: &quot;Consolas&quot;, monospace;
            }

            #content pre {
                background-color: #282c34;
                padding: 15px;
                border-radius: 5px;
                overflow-x: auto;
                margin-bottom: 1em;
            }

            #content img {
                max-width: 100%;
                border-radius: 5px;
                margin: 1em 0;
            }

            #content a {
                color: #61afef;
                text-decoration: none;
                border-bottom: 1px solid #61afef;
                transition: all 0.3s ease;
            }

            #content a:hover {
                color: #c678dd;
                border-bottom-color: #c678dd;
            }

            .loading {
                display: none;
                text-align: center;
                padding: 20px;
                font-style: italic;
                color: #888;
            }

            /* Scrollbar Styling */
            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: #1e1e1e;
            }

            ::-webkit-scrollbar-thumb {
                background: #888;
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #555;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;file-list&quot;&gt;&lt;/div&gt;
        &lt;div id=&quot;resizer&quot;&gt;&lt;/div&gt;
        &lt;div id=&quot;markdown-content&quot;&gt;
            &lt;div id=&quot;loading&quot; class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;
            &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;script&gt;
            const markdownFiles = [
                &quot;user-guide.md&quot;,
&quot;extension-docs.md&quot;,

            ];

            const fileList = document.getElementById(&quot;file-list&quot;);
            const markdownContent = document.getElementById(&quot;content&quot;);
            const loadingIndicator = document.getElementById(&quot;loading&quot;);
            const resizer = document.getElementById(&quot;resizer&quot;);

            // Create file list
            const ul = document.createElement(&quot;ul&quot;);
            markdownFiles.forEach((file) =&gt; {
                const li = document.createElement(&quot;li&quot;);
                li.textContent = file;
                li.onclick = () =&gt; loadMarkdownFile(file);
                ul.appendChild(li);
            });
            fileList.appendChild(ul);

            // Load markdown file
            function loadMarkdownFile(filename) {
                loadingIndicator.style.display = &quot;block&quot;;
                markdownContent.innerHTML = &quot;&quot;;

                fetch(`${filename}`)
                    .then((response) =&gt; {
                        if (!response.ok) {
                            throw new Error(&quot;Network response was not ok&quot;);
                        }
                        return response.text();
                    })
                    .then((content) =&gt; {
                        renderMarkdown(content);
                        loadingIndicator.style.display = &quot;none&quot;;
                    })
                    .catch((error) =&gt; {
                        console.error(&quot;Error:&quot;, error);
                        markdownContent.innerHTML = `&lt;p&gt;Error loading ${filename}: ${error.message}&lt;/p&gt;`;
                        loadingIndicator.style.display = &quot;none&quot;;
                    });
            }

            // Render markdown function
            function renderMarkdown(content) {
                marked.setOptions({
                    highlight: function (code, lang) {
                        const language = hljs.getLanguage(lang)
                            ? lang
                            : &quot;plaintext&quot;;
                        return hljs.highlight(code, { language }).value;
                    },
                    langPrefix: &quot;hljs language-&quot;,
                });
                markdownContent.innerHTML = marked(content);
            }

            // Resizable panel functionality
            let isResizing = false;

            resizer.addEventListener(&quot;mousedown&quot;, (e) =&gt; {
                isResizing = true;
                document.addEventListener(&quot;mousemove&quot;, resize);
                document.addEventListener(&quot;mouseup&quot;, stopResize);
            });

            function resize(e) {
                if (!isResizing) return;

                const newWidth = e.clientX;
                const minWidth = 200;
                const maxWidth = window.innerWidth / 2;

                if (newWidth &gt;= minWidth &amp;&amp; newWidth &lt;= maxWidth) {
                    fileList.style.width = newWidth + &quot;px&quot;;
                }
            }

            function stopResize() {
                isResizing = false;
                document.removeEventListener(&quot;mousemove&quot;, resize);
                document.removeEventListener(&quot;mouseup&quot;, stopResize);
            }

            // Load the first file by default
            if (markdownFiles.length &gt; 0) {
                loadMarkdownFile(markdownFiles[0]);
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<h3>custom_aider/docs/markdown-viewer-with-filelist.html</h3>
<div class="file-content">
<pre>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;Modern Markdown Viewer&lt;/title&gt;
        &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/marked/2.1.3/marked.min.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js&quot;&gt;&lt;/script&gt;
        &lt;link
            rel=&quot;stylesheet&quot;
            href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css&quot;
        /&gt;
        &lt;style&gt;
            @import url(&quot;https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&amp;display=swap&quot;);

            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                font-family: &quot;Inter&quot;, sans-serif;
                background-color: #1e1e1e;
                color: #e0e0e0;
                display: flex;
                height: 100vh;
                overflow: hidden;
            }

            #file-list {
                width: 300px;
                min-width: 200px;
                max-width: 50%;
                height: 100%;
                overflow-y: auto;
                background-color: #252526;
                padding: 20px;
                border-right: 1px solid #333;
                transition: width 0.1s ease;
            }

            #file-list ul {
                list-style-type: none;
            }

            #file-list li {
                cursor: pointer;
                padding: 10px;
                margin-bottom: 5px;
                background-color: #2d2d2d;
                border-radius: 5px;
                transition: all 0.3s ease;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            #file-list li:hover {
                background-color: #3a3a3a;
                transform: translateX(5px);
            }

            #resizer {
                width: 10px;
                height: 100%;
                background-color: #333;
                cursor: ew-resize;
            }

            #markdown-content {
                flex-grow: 1;
                padding: 30px;
                overflow-y: auto;
            }

            #content {
                max-width: 800px;
                margin: 0 auto;
                line-height: 1.6;
            }

            #content h1,
            #content h2,
            #content h3,
            #content h4,
            #content h5,
            #content h6 {
                margin-top: 1.5em;
                margin-bottom: 0.5em;
                color: #61afef;
            }

            #content p {
                margin-bottom: 1em;
            }

            #content code {
                background-color: #2c313a;
                padding: 2px 4px;
                border-radius: 3px;
                font-family: &quot;Consolas&quot;, monospace;
            }

            #content pre {
                background-color: #282c34;
                padding: 15px;
                border-radius: 5px;
                overflow-x: auto;
                margin-bottom: 1em;
            }

            #content img {
                max-width: 100%;
                border-radius: 5px;
                margin: 1em 0;
            }

            #content a {
                color: #61afef;
                text-decoration: none;
                border-bottom: 1px solid #61afef;
                transition: all 0.3s ease;
            }

            #content a:hover {
                color: #c678dd;
                border-bottom-color: #c678dd;
            }

            .loading {
                display: none;
                text-align: center;
                padding: 20px;
                font-style: italic;
                color: #888;
            }

            /* Scrollbar Styling */
            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: #1e1e1e;
            }

            ::-webkit-scrollbar-thumb {
                background: #888;
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #555;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;file-list&quot;&gt;&lt;/div&gt;
        &lt;div id=&quot;resizer&quot;&gt;&lt;/div&gt;
        &lt;div id=&quot;markdown-content&quot;&gt;
            &lt;div id=&quot;loading&quot; class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;
            &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;script&gt;
            const markdownFiles = [
                &lt;&lt;&lt;&lt;&lt;&lt;lessons&gt;&gt;&gt;&gt;&gt;&gt;
            ];

            const fileList = document.getElementById(&quot;file-list&quot;);
            const markdownContent = document.getElementById(&quot;content&quot;);
            const loadingIndicator = document.getElementById(&quot;loading&quot;);
            const resizer = document.getElementById(&quot;resizer&quot;);

            // Create file list
            const ul = document.createElement(&quot;ul&quot;);
            markdownFiles.forEach((file) =&gt; {
                const li = document.createElement(&quot;li&quot;);
                li.textContent = file;
                li.onclick = () =&gt; loadMarkdownFile(file);
                ul.appendChild(li);
            });
            fileList.appendChild(ul);

            // Load markdown file
            function loadMarkdownFile(filename) {
                loadingIndicator.style.display = &quot;block&quot;;
                markdownContent.innerHTML = &quot;&quot;;

                fetch(`${filename}`)
                    .then((response) =&gt; {
                        if (!response.ok) {
                            throw new Error(&quot;Network response was not ok&quot;);
                        }
                        return response.text();
                    })
                    .then((content) =&gt; {
                        renderMarkdown(content);
                        loadingIndicator.style.display = &quot;none&quot;;
                    })
                    .catch((error) =&gt; {
                        console.error(&quot;Error:&quot;, error);
                        markdownContent.innerHTML = `&lt;p&gt;Error loading ${filename}: ${error.message}&lt;/p&gt;`;
                        loadingIndicator.style.display = &quot;none&quot;;
                    });
            }

            // Render markdown function
            function renderMarkdown(content) {
                marked.setOptions({
                    highlight: function (code, lang) {
                        const language = hljs.getLanguage(lang)
                            ? lang
                            : &quot;plaintext&quot;;
                        return hljs.highlight(code, { language }).value;
                    },
                    langPrefix: &quot;hljs language-&quot;,
                });
                markdownContent.innerHTML = marked(content);
            }

            // Resizable panel functionality
            let isResizing = false;

            resizer.addEventListener(&quot;mousedown&quot;, (e) =&gt; {
                isResizing = true;
                document.addEventListener(&quot;mousemove&quot;, resize);
                document.addEventListener(&quot;mouseup&quot;, stopResize);
            });

            function resize(e) {
                if (!isResizing) return;

                const newWidth = e.clientX;
                const minWidth = 200;
                const maxWidth = window.innerWidth / 2;

                if (newWidth &gt;= minWidth &amp;&amp; newWidth &lt;= maxWidth) {
                    fileList.style.width = newWidth + &quot;px&quot;;
                }
            }

            function stopResize() {
                isResizing = false;
                document.removeEventListener(&quot;mousemove&quot;, resize);
                document.removeEventListener(&quot;mouseup&quot;, stopResize);
            }

            // Load the first file by default
            if (markdownFiles.length &gt; 0) {
                loadMarkdownFile(markdownFiles[0]);
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<h3>custom_aider/docs/runserver.bat</h3>
<div class="file-content">
<pre>python addlessonlist.py
start http://localhost:8888/index.html
python -m http.server 8888</pre>
</div>
<h3>custom_aider/docs/runserver.sh</h3>
<div class="file-content">
<pre>#!/bin/bash

# Run the Python script to add lesson list
python addlessonlist.py

# Open the default browser with the URL
# Using xdg-open for Linux systems
xdg-open http://localhost:8888/index.html &amp;

# Start Python HTTP server
python -m http.server 8888
</pre>
</div>
<h3>custom_aider/docs/user-guide.md</h3>
<div class="file-content">
<pre># Aider Extension User Guide

A comprehensive guide to using the extended Aider command-line interface with all its enhanced features.

## Table of Contents

1. [Getting Started](#getting-started)
2. [Basic Usage](#basic-usage)
3. [Working with Documents](#working-with-documents)
4. [Enhanced Git Integration](#enhanced-git-integration)
5. [Custom Chat Features](#custom-chat-features)
6. [Code Analysis Tools](#code-analysis-tools)
7. [Editor Integration](#editor-integration)
8. [Web and Voice Features](#web-and-voice-features)
9. [AIChat API Integration](#aichat-api-integration)
10. [Configuration](#configuration)
11. [Tips and Tricks](#tips-and-tricks)


## Getting Started

### Installation

1. Clone the repository:
```bash
git clone https://github.com/AbhijitKumarJ/Experimental_Aider_Extensions.git
cd Experimental_Aider_Extensions
```

2. Install required dependencies:
```bash
pip install aider-chat jinja2 llama-index-core llama-index-embeddings-huggingface pygments pyperclip streamlit requests
```

Optional dependencies for specific features:
```bash
# For voice commands
pip install SpeechRecognition

# For help system
pip install &#39;aider-chat[help]&#39; --extra-index-url https://download.pytorch.org/whl/cpu

# For enhanced editor features
pip install tkinter  # Usually comes with Python
```

3. Start the extended Aider:
```bash
python main.py
```

### Initial Configuration

1. Create a configuration file `.aider.conf.yml`:
```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree-only: true
```

2. Set up keywords file `.aider.keywords.json`:
```json
{
    &quot;api&quot;: &quot;REST API with JSON responses&quot;,
    &quot;tests&quot;: &quot;Unit tests using pytest with mocking&quot;
}
```

## Basic Usage

### Starting a Session

```bash
# Start with default settings
python main.py

# Start with specific model
python main.py --model gemini/gemini-1.5-flash-latest

# Start with specific directory
python main.py /path/to/project
```

### Getting Help

```bash
# Show all available commands
&gt; /help

# Get help for specific command
&gt; /help createragfromdoc
```

## Working with Documents

### RAG (Retrieval Augmented Generation)

Creating and querying document-based RAGs:

```bash
# Create a RAG from a document
&gt; /createragfromdoc docs_rag ./documentation.md

# List all available RAGs
&gt; /listrag

# Query a RAG
&gt; /queryragfromdoc docs_rag &quot;How do I configure logging?&quot;

# Delete a RAG when no longer needed
&gt; /deleterag docs_rag
```

### File Management

Enhanced file operations:

```bash
# Show files in chat with details
&gt; /files
&gt; /files *.py  # Filter by pattern

# Show file statistics
&gt; /stats

# Enhanced add command with validation
&gt; /zadd file1.py file2.py

# Enhanced drop with confirmation
&gt; /zdrop file1.py
```

## Enhanced Git Integration

### Git Log and Status

```bash
# Show pretty git log with graphs
&gt; /glog
&gt; /glog -n 5  # Show last 5 commits
&gt; /glog --all  # Show all branches
&gt; /glog --stat  # Show file statistics

# Enhanced commit with statistics
&gt; /zcommit &quot;Added new feature&quot;
```

### Common Git Workflows

```bash
# Add files with status check
&gt; /zadd *.py

# Commit with automatic statistics
&gt; /zcommit

# Review changes
&gt; /glog --stat
```

## Custom Chat Features

### Using Keyword Substitution

1. Define keywords in `.aider.keywords.json`:
```json
{
    &quot;api&quot;: &quot;REST API with JSON responses&quot;,
    &quot;tests&quot;: &quot;Unit tests using pytest with mocking&quot;
}
```

2. Use in chat:
```bash
# Use keywords in messages
&gt; /customchat Create @text-tests for the login function

# Keywords will be expanded automatically
&gt; /customchat Add @text-api endpoint for user registration
```

### Context Management

```bash
# Save and view current chat context
&gt; /context_show

# Save a backup of the current chat context
&gt; /context_backup

# Load a previous chat context
&gt; /context_load

# Clear chat with history backup
&gt; /zclear
```

## Code Analysis Tools

### Code Explanation

```bash
# Get interactive explanation of code
&gt; /explain MyClass
&gt; /explain my_function --level=deep
&gt; /explain process_data --level=eli5
```

### Code Statistics

```bash
# Get detailed file statistics
&gt; /stats

# Show specific file details
&gt; /files mymodule.py
```

## Editor Integration

### Clipboard Integration

```bash
# Apply clipboard content as edits
&gt; /clip-edit myfile.py
```

### GUI Editors

```bash
# Launch Tkinter editor
&gt; /editor_tkinter
```

## Web and Voice Features

### Web Integration

```bash
# Enhanced web command with retry
&gt; /zweb https://example.com/docs

# Content is automatically saved to .extn_aider/temp/web/
```

### Voice Integration

```bash
# Enhanced voice command
&gt; /zvoice
# Speak your command
# Confirm accuracy when prompted
```

## AIChat API Integration

```bash
# Query a RAG using the aichat API
&gt; /aichat_rag_query aichat-wiki &quot;How does feature X work?&quot;
```

## Configuration

### Directory Structure

The extension creates these directories:
```
.extn_aider/
├── rags/        # RAG indexes
├── temp/
│   ├── context_backup/ # Context backups
│   ├── context/       # Context reports
│   ├── web/           # Scraped content
│   └── backups/       # File backups
└── explanations/# Code explanations
```

### Configuration Files

1. `.aider.conf.yml` - Main configuration:
```yaml
model: gemini/gemini-1.5-flash-latest
map-tokens: 1024
subtree-only: true
```

2. `.extn_aider.keywords.json` - Custom keywords:
```json
{
    &quot;api&quot;: &quot;REST API with JSON responses&quot;,
    &quot;tests&quot;: &quot;Unit tests using pytest with mocking&quot;
}
```

## Tips and Tricks

### Keyboard Shortcuts

- `Ctrl+C` - Cancel current operation
- `Ctrl+D` - Exit Aider
- `Ctrl+S` - Save in editors
- `Esc` - Cancel in editors

### Efficiency Tips

1. Use command completion:
   ```bash
   # Press Tab to complete commands
   &gt; /cr&lt;Tab&gt;  # Completes to /createragfromdoc
   ```

2. Use patterns in file commands:
   ```bash
   &gt; /files *.py  # Show only Python files
   ```

3. Quick context check:
   ```bash
   &gt; /stats  # Quick overview of files
   ```

### Common Workflows

1. Document Analysis:
   ```bash
   &gt; /createragfromdoc docs docs.md
   &gt; /queryragfromdoc docs &quot;How to configure?&quot;
   ```

2. Code Review:
   ```bash
   &gt; /zadd *.py
   &gt; /stats
   &gt; /explain MainClass
   ```

3. Git Operations:
   ```bash
   &gt; /zadd modified_files.py
   &gt; /glog --stat
   &gt; /zcommit &quot;Updates&quot;
   ```

### Troubleshooting

1. Command not working:
   - Check if model is supported
   - Verify file paths are correct
   - Check for required dependencies

2. RAG issues:
   - Ensure document is text/markdown
   - Check document size is reasonable
   - Verify unique RAG nicknames

3. Editor issues:
   - Check for required packages
   - Verify clipboard content format
   - Check file permissions

### Best Practices

1. Regular backups:
   ```bash
   &gt; /context_backup  # Saves context regularly
   ```

2. Organized RAGs:
   ```bash
   &gt; /listrag  # Review existing RAGs
   &gt; /deleterag unused_rag  # Clean up
   ```

3. Efficient keyword use:
   - Keep keywords focused and clear
   - Update keywords as needed
   - Use descriptive expansions

4. Version control:
   ```bash
   &gt; /glog  # Regular status checks
   &gt; /zcommit  # Frequent small commits
   ```

</pre>
</div>
<h3>custom_aider/monkey_patch.py</h3>
<div class="file-content">
<pre>&quot;&quot;&quot;Early monkey-patching of aider classes&quot;&quot;&quot;
import os
import sys
from pathlib import Path

def monkey_patch_aider():
    &quot;&quot;&quot;Monkey patch aider classes before any aider imports&quot;&quot;&quot;
    # Add our custom_aider directory to the Python path
    custom_aider_dir = Path(__file__).parent
    if str(custom_aider_dir) not in sys.path:
        sys.path.insert(0, str(custom_aider_dir))
    
    # First import our custom coder
    from custom_aider.custom_coder import CustomCoder
    
    # Then patch aider&#39;s coders
    import aider.coders as coders
    coders.Coder = CustomCoder
    
    # Also patch the base coder module
    import aider.coders.base_coder
    aider.coders.base_coder.Coder = CustomCoder
    
    # Ensure commands directory is in path
    commands_dir = custom_aider_dir / &quot;commands&quot;
    os.makedirs(commands_dir, exist_ok=True)
    
    print(&quot;Custom aider classes loaded and patched&quot;)</pre>
</div>
</div>
</div>
</body>
</html>
